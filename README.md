# Документация по модулю DnevnikFormatter
[СВЯЗЬ](https://t.me/Sirop1)

[ПОЛУЧИТЬ ТОКЕН](https://androsovpavel.pythonanywhere.com/)
## СКОРО
 - Автоматическая регистрация через госуслуги
 - Асинхронная работа
 - Расширенная статистика по классам по школе
 - тг бот??

### Ключевые возможности

- **Расписание**: Получение расписания за одну дату или период с информацией о предметах, домашних заданиях, учителях и оценках.
- **Оценки**: Извлечение последних оценок, оценок за период или итоговых оценок за четверть.
- **Статистика**: Формирование рейтингов учеников, гистограмм оценок и общей статистики класса.
- **Учителя**: Получение данных об учителях группы.
- **Оптимизация**: Кэширование данных для минимизации запросов.
- **Логирование**: Подробные отладочные сообщения.

### Зависимости

- **Python**: 3.6 или выше.
- **pydnevnikruapi**: Библиотека для API Дневник.ру.
- Встроенные модули: `datetime`, `typing`, `statistics`, `collections.defaultdict`.

**Установка**:

```bash
pip install pydnevnikruapi
```

Требуется токен API Дневник.ру, получаемый через авторизацию в системе.

## 2. Вспомогательные методы

Эти методы используются внутри главных методов для обработки данных, форматирования или кэширования. Они не предназначены для прямого вызова, но их понимание важно для диагностики и расширения функциональности.

### 2.1. `_log`

**Назначение**: Логирует отладочные сообщения, если включен `debug_mode`. Используется для отслеживания работы всех методов.

**Параметры**:
- `message: str` — Сообщение для логирования.

**Возвращает**: `None`

**Исключения**: Нет.

**Случаи ошибок**: Не применимо.

**Примеры**:

```python
formatter._log("Тестовое сообщение")
# Вывод (если debug_mode=True): Тестовое сообщение
```

**Рекомендации**:
- Включайте `debug_mode=True` при тестировании для просмотра логов.
- Отключите `debug_mode` в продакшене для уменьшения вывода.

### 2.2. `_load_subjects`

**Назначение**: Загружает список предметов группы и кэширует их в `_subject_cache`. Используется для преобразования ID предметов в названия.

**Параметры**: Нет.

**Возвращает**: `None`

**Исключения**: Нет (ошибки логируются).

**Случаи ошибок**:
- Ошибка API.
- Отсутствие предметов в ответе API.

**Примеры**:

```python
formatter._load_subjects()
# Лог: Загружено предметов: 19
```

**Логи**:
```
Загружено предметов: 19
```

**Рекомендации**:
- Проверьте `_subject_cache`:
  ```python
  print(formatter._subject_cache)
  # Вывод: {630691695693757: 'Алг. и нач. анализа', ...}
  ```
- Если кэш пуст, проверьте `group_id` и доступность API.

### 2.3. `_load_students`

**Назначение**: Загружает список учеников группы и кэширует их в `_student_cache`. Используется для рейтингов и статистики.

**Параметры**: Нет.

**Возвращает**: `None`

**Исключения**: Нет (ошибки логируются).

**Случаи ошибок**:
- Ошибка API.
- Отсутствие учеников.

**Примеры**:

```python
formatter._load_students()
# Лог: Загружено учеников: 35
```

**Логи**:
```
Загружено учеников: 35
```

**Рекомендации**:
- Проверьте `_student_cache` для диагностики.
- Убедитесь, что `group_id` соответствует группе.

### 2.4. `_load_teachers`

**Назначение**: Загружает список учителей школы и кэширует их в `_teacher_cache`. Используется для отображения имен учителей.

**Параметры**: Нет.

**Возвращает**: `None`

**Исключения**: Нет (ошибки логируются).

**Случаи ошибок**:
- Ошибка API.
- Отсутствие учителей.

**Примеры**:

```python
formatter._load_teachers()
# Лог: Загружено учителей: 127
```

**Логи**:
```
Загружено учителей: 127
```

**Рекомендации**:
- Если `_teacher_cache` пуст, проверьте `school_id`.

### 2.5. `_format_lesson_time`

**Назначение**: Преобразует номер урока (1–7) в строку времени (например, `"08:30-09:15"`). Используется в `_get_formatted_schedule_day`.

**Параметры**:
- `lesson_number: int` — Номер урока.

**Возвращает**:
- `str`: Время урока или `"Неизвестное время"`.

**Исключения**: Нет.

**Случаи ошибок**:
- Номер урока вне диапазона 1–7.

**Примеры**:

```python
print(formatter._format_lesson_time(1))
# Вывод: 08:30-09:15

print(formatter._format_lesson_time(8))
# Вывод: Неизвестное время
```

**Рекомендации**:
- Адаптируйте словарь `lesson_times` для другого расписания:
  ```python
  lesson_times = {1: "09:00-09:45", ...}
  ```

### 2.6. `_get_lesson_info`

**Назначение**: Получает данные об уроке по ID, используя кэш или API. Используется в `_get_formatted_schedule_day` и `get_formatted_marks`.

**Параметры**:
- `lesson_id: str` — ID урока.
- `force_refresh: bool` — Принудительное обновление кэша (по умолчанию `False`).

**Возвращает**:
- `Dict`: Данные урока (`subject`, `date`, `works`).
- Пустой словарь при ошибке.

**Исключения**: Нет (ошибки логируются).

**Случаи ошибок**:
- Ошибка API.
- Некорректный `lesson_id`.

**Примеры**:

```python
lesson = formatter._get_lesson_info("2336122272470595677")
print(lesson.get('subject', {}).get('name'))
# Вывод: Алг. и нач. анализа
```

```python
lesson = formatter._get_lesson_info("invalid_id")
print(lesson)
# Вывод: {}
```

**Логи**:
```
Загружена информация об уроке 2336122272470595677: Тема урока (предмет: Алг. и нач. анализа)
Ошибка при получении урока invalid_id: ...
```

**Рекомендации**:
- Используйте `force_refresh=True` только при необходимости.
- Проверяйте наличие ключа `subject`.

### 2.7. `_get_quarter_period_id`

**Назначение**: Получает ID и даты учебного периода для четверти. Используется в `get_formatted_final_marks`, `get_class_ranking`, `get_subject_stats`, `get_class_stats`, `get_subject_ranking`.

**Параметры**:
- `study_year: int` — Учебный год.
- `quarter: int` — Номер четверти (1–4).

**Возвращает**:
- `Tuple[int, datetime, datetime]`: ID периода, начальная и конечная даты.
- `None` при ошибке.

**Исключения**: Нет (ошибки логируются).

**Случаи ошибок**:
- Ошибка API.
- Отсутствие периода.

**Примеры**:

```python
period = formatter._get_quarter_period_id(2024, 4)
if period:
    period_id, start_date, end_date = period
    print(f"Период: {start_date} - {end_date}")
# Вывод: Период: 2025-02-01 00:00:00 - 2025-05-31 00:00:00
```

```python
period = formatter._get_quarter_period_id(2024, 5)
print(period)
# Вывод: None
```

**Логи**:
```
Не найдены периоды для четверти 5 в учебном году 2024
```

**Рекомендации**:
- Убедитесь, что `quarter` в диапазоне 1–4.
- Проверьте учебный год.

## 3. Главные методы

Эти методы выполняют ключевые задачи, такие как получение расписания, оценок и статистики. Они используют вспомогательные методы для обработки данных.

### 3.1. `get_formatted_schedule`

**Назначение**: Получает расписание уроков за одну дату или период с деталями о предметах, домашних заданиях, учителях и оценках. Использует `_get_formatted_schedule_day`, `_format_lesson_time`, `_get_lesson_info`, `_load_subjects`, `_load_teachers`.

**Параметры**:
- `start_date: datetime` — Начальная дата.
- `end_date: Optional[datetime]` — Конечная дата (если `None`, за одну дату).

**Возвращает**:
- `List[Dict[str, str]]`: Список уроков за `start_date` (если `end_date=None`).
- `Dict[str, List[Dict[str, str]]]`: Словарь с ключами — датами (`YYYY-MM-DD`), значениями — списками уроков:
  - `time: str` — Время.
  - `subject: str` — Предмет.
  - `homework: str` — Домашнее задание.
  - `title: str` — Тема.
  - `teacher: str` — Учитель.
  - `marks: str` — Оценки.
- Пустой список/словарь при ошибке.

**Исключения**:
- `ValueError`: Если `end_date` раньше `start_date`.

**Случаи ошибок**:
- Ошибка API.
- Отсутствие уроков.
- Некорректные данные.

**Примеры**:

```python
from datetime import datetime
from dnevnik_formatter import DnevnikFormatter

formatter = DnevnikFormatter(token="", debug_mode=True)

# За одну дату
schedule = formatter.get_formatted_schedule(datetime(2025, 5, 14))
for lesson in schedule:
    print(f"{lesson['time']} | {lesson['subject']} | {lesson['marks']}")
```

**Вывод**:
```
08:30-09:15 | Алг. и нач. анализа | Нет оценок
09:20-10:05 | Физика | 4
```

```python
# За период
schedule = formatter.get_formatted_schedule(datetime(2025, 5, 14), datetime(2025, 5, 15))
for date, lessons in schedule.items():
    print(f"Дата: {date}")
    for lesson in lessons:
        print(f"  {lesson['time']} | {lesson['subject']} | {lesson['homework']}")
```

**Вывод**:
```
Дата: 2025-05-14
  08:30-09:15 | Алг. и нач. анализа | Выполнить задания
  09:20-10:05 | Физика | Подготовить доклад
Дата: 2025-05-15
  08:30-09:15 | История | Прочитать параграф
```

**Логи**:
```
Ответ get_group_lessons_info для 2025-05-14: 10 уроков
Оценки за 2025-05-07 - 2025-05-14: 5 оценок
```

**Рекомендации**:
- Ограничивайте период (например, неделя) для быстрого ответа.
- Проверяйте тип результата (`list` или `dict`).
- Очищайте `_schedule_cache` при необходимости:
  ```python
  formatter._schedule_cache.clear()
  ```

### 3.2. `get_formatted_marks`

**Назначение**: Получает оценки за период, сгруппированные по предметам, с датой, значением и комментарием. Использует `_get_lesson_info`, `_load_subjects`.

**Параметры**:
- `start_date: datetime` — Начальная дата.
- `end_date: Optional[datetime]` — Конечная дата (по умолчанию `start_date`).

**Возвращает**:
- `Dict[str, List[Dict[str, str]]]`: Словарь:
  - Ключи — названия предметов.
  - Значения — списки оценок (`date`, `value`, `comment`).
- Пустой словарь при ошибке.

**Исключения**: Нет (ошибки логируются).

**Случаи ошибок**:
- Ошибка API.
- Отсутствие оценок.
- Некорректные данные урока.

**Примеры**:

```python
from datetime import datetime

# За одну дату
marks = formatter.get_formatted_marks(datetime(2025, 5, 14))
for subject, mark_list in marks.items():
    print(f"{subject}:")
    for mark in mark_list:
        print(f"  {mark['date']} - {mark['value']} ({mark['comment']})")
```

**Вывод**:
```
Алг. и нач. анализа:
  14.05.2025 - 3 ()
Физика:
  14.05.2025 - 4 (Хорошо)
```

```python
# За период
marks = formatter.get_formatted_marks(datetime(2025, 5, 12), datetime(2025, 5, 14))
for subject, mark_list in marks.items():
    print(f"{subject}:")
    for mark in mark_list:
        print(f"  {mark['date']} - {mark['value']}")
```

**Вывод**:
```
Алг. и нач. анализа:
  12.05.2025 - 4
  14.05.2025 - 3
Физика:
  13.05.2025 - 4
  14.05.2025 - 4
```

**Логи**:
```
Получено 5 оценок за 2025-05-07 - 2025-05-14 для person_id=...
Lesson IDs в оценках: ['2336122272470595677']
```

**Рекомендации**:
- Проверяйте совпадение дат урока и оценки в логах.
- Если предметы неизвестны, проверьте `_subject_cache`.

### 3.3. `get_last_marks`

**Назначение**: Получает последние оценки за 90 дней с фильтрацией по предмету и распределением оценок в классе. Использует `_get_lesson_info`, `_load_subjects`, `_load_students`.

**Параметры**:
- `count: int` — Количество оценок (по умолчанию 5).
- `subject_id: Optional[int]` — ID предмета (если `None`, все предметы).

**Возвращает**:
- `List[Dict[str, any]]`: Список оценок:
  - `subject: str` — Предмет.
  - `title: str` — Тип работы.
  - `mark: str` — Оценка.
  - `class_distribution: Dict[str, int]` — Распределение оценок.
  - `date: str` — Дата (`DD.MM.YYYY`).
- Пустой список при ошибке.

**Исключения**: Нет (ошибки логируются).

**Случаи ошибок**:
- Ошибка API.
- Отсутствие оценок.
- Некорректный `subject_id`.

**Примеры**:

```python
# Все предметы
marks = formatter.get_last_marks(count=3)
for mark in marks:
    print(f"{mark['subject']}: {mark['mark']} ({mark['date']})")
```

**Вывод**:
```
Алг. и нач. анализа: 3 (14.05.2025)
Физика: 4 (13.05.2025)
История: 5 (12.05.2025)
```

```python
# По предмету
subject_id = 630691695693757  # Алг. и нач. анализа
marks = formatter.get_last_marks(count=2, subject_id=subject_id)
for mark in marks:
    print(f"{mark['subject']}: {mark['mark']} ({mark['class_distribution']})")
```

**Вывод**:
```
Алг. и нач. анализа: 3 ( {'3': 5, '4': 10, '5': 2} )
Алг. и нач. анализа: 4 ( {'3': 3, '4': 12, '5': 2} )
```

**Логи**:
```
Получено 15 оценок за период 2025-02-16 - 2025-05-17 для person_id=...
Оценка: lesson_id=2336122272470595677, value=3, mark_date=2025-05-14
```

**Рекомендации**:
- Используйте `subject_id` из `_subject_cache`.
- Ограничивайте `count` для быстрого ответа.

### 3.4. `get_formatted_final_marks`

**Назначение**: Получает итоговые оценки за четверть с средней оценкой. Использует `_get_quarter_period_id`, `_load_subjects`.

**Параметры**:
- `study_year: int` — Учебный год.
- `quarter: int` — Номер четверти (1–4).

**Возвращает**:
- `List[Dict[str, str]]`: Список:
  - `название предмета: str` — Предмет.
  - `оценки: List[str]` — Оценки.
  - `итог: str` — Средняя оценка.
- Пустой список при ошибке.

**Исключения**:
- `ValueError`: Если `quarter` не в диапазоне 1–4.

**Случаи ошибок**:
- Ошибка API.
- Отсутствие оценок.

**Примеры**:

```python
marks = formatter.get_formatted_final_marks(2024, 4)
for mark in marks:
    print(f"{mark['название предмета']}: {mark['итог']} ({mark['оценки']})")
```

**Вывод**:
```
Алг. и нач. анализа: 3.5 (['3', '4'])
Физика: 4.0 (['4', '4'])
```

```python
try:
    marks = formatter.get_formatted_final_marks(2024, 5)
except ValueError as e:
    print(f"Ошибка: {e}")
```

**Вывод**:
```
Ошибка: Номер четверти должен быть от 1 до 4
```

**Логи**:
```
Получено 10 оценок за 2025-02-01 - 2025-05-31 для person_id=...
```

**Рекомендации**:
- Проверяйте, являются ли оценки числовыми.
- Используйте для отчетов по четверти.

### 3.5. `get_class_ranking`

**Назначение**: Формирует рейтинг учеников класса по средней оценке за четверть. Использует `_get_quarter_period_id`, `_load_students`, `_load_subjects`.

**Параметры**:
- `study_year: int` — Учебный год.
- `quarter: int` — Номер четверти (1–4).

**Возвращает**:
- `List[Dict]`: Список:
  - `name: str` — Имя ученика.
  - `avg_grade: float` — Средняя оценка.
  - `marks_count: int` — Количество оценок.
- Пустой список при ошибке.

**Исключения**:
- `ValueError`: Если `quarter` не в диапазоне 1–4.

**Случаи ошибок**:
- Ошибка API.
- Отсутствие оценок.

**Примеры**:

```python
ranking = formatter.get_class_ranking(2024, 4)
for student in ranking[:3]:
    print(f"{student['name']}: {student['avg_grade']} ({student['marks_count']} оценок)")
```

**Вывод**:
```
Иванов И.: 4.5 (20 оценок)
Петров П.: 4.2 (18 оценок)
Сидоров С.: 4.0 (15 оценок)
```

```python
try:
    ranking = formatter.get_class_ranking(2024, 5)
except ValueError as e:
    print(f"Ошибка: {e}")
```

**Вывод**:
```
Ошибка: Номер четверти должен быть от 1 до 4
```

**Логи**:
```
Ошибка при получении оценок для ученика 12345, предмет 630691695693757: ...
```

**Рекомендации**:
- Проверьте `_student_cache` перед вызовом.
- Используйте для анализа успеваемости класса.

### 3.6. `get_subject_stats`

**Назначение**: Получает гистограмму оценок по предмету за четверть. Использует `_get_quarter_period_id`, `_load_subjects`.

**Параметры**:
- `study_year: int` — Учебный год.
- `quarter: int` — Номер четверти (1–4).
- `subject_id: int` — ID предмета.

**Возвращает**:
- `Dict[str, int]`: Оценки и их количество.
- Пустой словарь при ошибке.

**Исключения**:
- `ValueError`: Если `quarter` не в диапазоне 1–4.

**Случаи ошибок**:
- Ошибка API.
- Отсутствие оценок.

**Примеры**:

```python
stats = formatter.get_subject_stats(2024, 4, 630691695693757)
print(stats)
```

**Вывод**:
```
{'3': 10, '4': 15, '5': 5}
```

```python
stats = formatter.get_subject_stats(2024, 4, 999999)  # Некорректный ID
print(stats)
```

**Вывод**:
```
{}
```

**Логи**:
```
Ошибка при получении статистики по предмету 999999: ...
```

**Рекомендации**:
- Используйте `subject_id` из `_subject_cache`.
- Проверяйте логи при пустом результате.

### 3.7. `get_subject_ranking`

**Назначение**: Формирует рейтинг учеников по предмету за четверть. Использует `_get_quarter_period_id`, `_load_students`, `_load_subjects`.

**Параметры**:
- `study_year: int` — Учебный год.
- `quarter: int` — Номер четверти (1–4).
- `subject_id: int` — ID предмета.

**Возвращает**:
- `List[Dict]`: Список:
  - `name: str` — Имя ученика.
  - `avg_grade: float` — Средняя оценка.
  - `marks_count: int` — Количество оценок.
- Пустой список при ошибке.

**Исключения**:
- `ValueError`: Если `quarter` не в диапазоне 1–4.

**Случаи ошибок**:
- Ошибка API.
- Отсутствие оценок.

**Примеры**:

```python
ranking = formatter.get_subject_ranking(2024, 4, 630691695693757)
for student in ranking[:3]:
    print(f"{student['name']}: {student['avg_grade']}")
```

**Вывод**:
```
Иванов И.: 4.7
Петров П.: 4.3
Сидоров С.: 4.0
```

```python
ranking = formatter.get_subject_ranking(2024, 4, 999999)
print(ranking)
```

**Вывод**:
```
[]
```

**Логи**:
```
Ошибка при получении оценок для ученика 12345, предмет 999999: ...
```

**Рекомендации**:
- Используйте для анализа успеваемости по предмету.

### 3.8. `get_class_stats`

**Назначение**: Получает статистику класса за четверть (количество оценок, средняя оценка, распределение). Использует `_get_quarter_period_id`, `_load_subjects`.

**Параметры**:
- `study_year: int` — Учебный год.
- `quarter: int` — Номер четверти (1–4).

**Возвращает**:
- `Dict`: Статистика:
  - `total_marks: int` — Количество оценок.
  - `average_class_grade: float` — Средняя оценка.
  - `grade_distribution: Dict[str, float]` — Процентное распределение.
- Пустой словарь при ошибке.

**Исключения**:
- `ValueError`: Если `quarter` не в диапазоне 1–4.

**Случаи ошибок**:
- Ошибка API.
- Отсутствие оценок.

**Примеры**:

```python
stats = formatter.get_class_stats(2024, 4)
print(stats)
```

**Вывод**:
```
{
    'total_marks': 500,
    'average_class_grade': 3.8,
    'grade_distribution': {'3': 40.0, '4': 50.0, '5': 10.0}
}
```

```python
try:
    stats = formatter.get_class_stats(2024, 5)
except ValueError as e:
    print(f"Ошибка: {e}")
```

**Вывод**:
```
Ошибка: Номер четверти должен быть от 1 до 4
```

**Логи**:
```
Ошибка при получении статистики по предмету 630691695693757: ...
```

**Рекомендации**:
- Используйте для общей оценки успеваемости.

### 3.9. `get_group_teachers`

**Назначение**: Получает список учителей группы за период на основе расписания. Использует `_load_teachers`.

**Параметры**:
- `start_date: Optional[datetime]` — Начальная дата (по умолчанию текущая минус 7 дней).
- `end_date: Optional[datetime]` — Конечная дата (по умолчанию текущая плюс 30 дней).

**Возвращает**:
- `List[Dict[str, str]]`: Список учителей:
  - `id: str` — ID.
  - `fullName: str` — Полное имя.
  - `shortName: str` — Краткое имя.
  - `subjects: str` — Предметы.
  - `email: str` — Email.
  - `position: str` — Должность.
- Пустой список при ошибке.

**Исключения**:
- `ValueError`: Если `end_date` раньше `start_date`.

**Случаи ошибок**:
- Ошибка API.
- Отсутствие уроков.

**Примеры**:

```python
teachers = formatter.get_group_teachers()
for teacher in teachers:
    print(f"{teacher['shortName']} ({teacher['subjects']})")
```

**Вывод**:
```
Татьяна К. (Алг. и нач. анализа)
Иван П. (Физика)
```

```python
from datetime import datetime
teachers = formatter.get_group_teachers(datetime(2025, 5, 1), datetime(2025, 5, 7))
for teacher in teachers:
    print(f"{teacher['shortName']} - {teacher['email']}")
```

**Вывод**:
```
Татьяна К. - t.k@example.com
Иван П. - i.p@example.com
```

**Логи**:
```
Добавлен учитель 754039: Татьяна К.
```

**Рекомендации**:
- Увеличьте период, если список пуст.
- Используйте `_teacher_cache` для быстрого доступа.

## 4. Применение

### 4.1. Мониторинг расписания и оценок

**Задача**: Получить расписание за неделю и оценки за этот же период.

```python
from datetime import datetime
from dnevnik_formatter import DnevnikFormatter

formatter = DnevnikFormatter(token="", debug_mode=True)
start_date = datetime(2025, 5, 12)
end_date = datetime(2025, 5, 16)

# Расписание
schedule = formatter.get_formatted_schedule(start_date, end_date)
for date, lessons in schedule.items():
    print(f"\nДата: {date}")
    if not lessons:
        print("  Нет уроков")
    else:
        for lesson in lessons:
            print(f"  {lesson['time']} | {lesson['subject']} | {lesson['marks']}")

# Оценки
marks = formatter.get_formatted_marks(start_date, end_date)
for subject, mark_list in marks.items():
    print(f"\n{subject}:")
    for mark in mark_list:
        print(f"  {mark['date']} - {mark['value']}")
```

**Вывод**:
```
Дата: 2025-05-12
  08:30-09:15 | Алг. и нач. анализа | 4
  09:20-10:05 | Физика | Нет оценок
...
Дата: 2025-05-16
  Нет уроков

Алг. и нач. анализа:
  12.05.2025 - 4
  14.05.2025 - 3
Физика:
  13.05.2025 - 4
```

### 4.2. Анализ успеваемости

**Задача**: Получить итоговые оценки за четверть и рейтинг класса.

```python
marks = formatter.get_formatted_final_marks(2024, 4)
print("Итоговые оценки:")
for mark in marks:
    print(f"{mark['название предмета']}: {mark['итог']}")

ranking = formatter.get_class_ranking(2024, 4)
print("\nРейтинг класса:")
for student in ranking[:3]:
    print(f"{student['name']}: {student['avg_grade']}")
```

**Вывод**:
```
Итоговые оценки:
Алг. и нач. анализа: 3.5
Физика: 4.0

Рейтинг класса:
Иванов И.: 4.5
Петров П.: 4.2
Сидоров С.: 4.0
```

### 4.3. Статистика по предмету

**Задача**: Получить гистограмму оценок и рейтинг по предмету.

```python
subject_id = 630691695693757  # Алг. и нач. анализа
stats = formatter.get_subject_stats(2024, 4, subject_id)
print("Гистограмма оценок:", stats)

ranking = formatter.get_subject_ranking(2024, 4, subject_id)
print("\nРейтинг по предмету:")
for student in ranking[:3]:
    print(f"{student['name']}: {student['avg_grade']}")
```

**Вывод**:
```
Гистограмма оценок: {'3': 10, '4': 15, '5': 5}

Рейтинг по предмету:
Иванов И.: 4.7
Петров П.: 4.3
Сидоров С.: 4.0
```

## 5. Обработка ошибок

### Стратегии

- **Логирование**: Проверяйте логи с `"Ошибка при"` для диагностики.
- **Пустые результаты**: Методы возвращают пустые списки/словари при ошибках.
- **Исключения**: Проверяйте `ValueError` для некорректных параметров.

### Примеры

```python
schedule = formatter.get_formatted_schedule(datetime(2025, 5, 14))
if not schedule:
    print("Ошибка или нет уроков")
else:
    for lesson in schedule:
        print(lesson['subject'])
```

```python
try:
    formatter.get_formatted_final_marks(2024, 5)
except ValueError as e:
    print(f"Ошибка: {e}")
```

## 6. Ограничения и рекомендации

### Ограничения

- Зависимость от стабильности API Дневник.ру.
- Кэши могут содержать устаревшие данные.
- Производительность снижается для больших классов.
- Фиксированное время уроков в `_format_lesson_time`.

### Рекомендации

- Используйте `debug_mode=True` для тестирования.
- Ограничивайте периоды дат.
- Храните токен в переменной окружения.
- Сверяйте результаты с интерфейсом Дневник.ру.

## 7. Заключение

`DnevnikFormatter` упрощает работу с API Дневник.ру, предоставляя методы для получения расписания, оценок и статистики. Вспомогательные методы обеспечивают кэширование и форматирование, а главные методы решают ключевые задачи. Документация с примерами помогает интегрировать класс в проекты, такие как боты или аналитические системы.

Для доработок или вопросов обратитесь к разработчику.
