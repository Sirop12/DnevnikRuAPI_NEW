import uuid
import aiofiles
import asyncio
from pydnevnikruapi.aiodnevnik import dnevnik
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import statistics
from collections import defaultdict
import json
import re
from openai import AsyncOpenAI
import os
import logging
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.prompt import Prompt, IntPrompt
from rich.text import Text
from rich import box
# Ключевая константа: API-ключ для интеграции с DeepSeek через OpenRouter
# Этот ключ используется для отправки запросов к AI для анализа данных
API_KEY = "API_KEY"
logging.basicConfig(filename='bot.log',level=logging.INFO,format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

class DnevnikFormatter:
    """
    Асинхронный класс для обработки и форматирования данных, полученных через API Дневник.ру.
    Предоставляет методы для работы с расписанием, оценками, информацией об учителях и статистикой класса.
    Использует кэширование для оптимизации запросов к API и обрабатывает ошибки для повышения надежности.
    
    **Назначение**:
    Этот класс предназначен для упрощения взаимодействия с API Дневник.ру, предоставляя высокоуровневые методы
    для получения отформатированных данных, таких как расписание уроков, оценки, списки тестов и рейтинги учеников.
    Он асинхронный, что делает его идеальным для интеграции в приложения с высокой нагрузкой, такие как Telegram-боты.

    **Особенности**:
    - Поддержка асинхронных запросов через `pydnevnikruapi.aiodnevnik`.
    - Кэширование данных (уроки, предметы, ученики, учителя) для минимизации запросов к API.
    - Интеграция с AI (DeepSeek) для анализа данных (например, расписания, оценок, рейтингов).
    - Гибкая обработка ошибок с логированием для упрощения отладки.
    - Поддержка работы с четвертями, семестрами и учебными годами.

    **Применение**:
    Используется в приложениях, где требуется доступ к данным Дневник.ру, например, в Telegram-ботах для отправки
    расписания, оценок или уведомлений о тестах. Подходит для образовательных платформ, школьных порталов и личных
    ассистентов.

    **Ограничения**:
    - Требуется действительный токен API Дневник.ру.
    - Зависит от структуры ответов API, которая может измениться.
    - Требуется файл `prompts.json` для AI-анализа.
    """

    def __init__(self, token: str, debug_mode: bool = True):
        """
        Инициализирует экземпляр класса DnevnikFormatter, устанавливая соединение с API Дневник.ру
        и подготавливая кэши для данных.

        **Параметры**:
        - token (str): Токен авторизации для доступа к API Дневник.ру. Должен быть действительным
          и предоставлять доступ к данным пользователя (ученика, родителя или учителя).
        - debug_mode (bool, optional): Если True, включает подробное логирование для отладки.
          Полезно для разработчиков, чтобы отслеживать запросы к API и ошибки. По умолчанию True.

        **Алгоритм работы**:
        1. Сохраняет переданный токен и режим отладки в атрибуты экземпляра.
        2. Инициализирует переменные для хранения идентификаторов (person_id, school_id, group_id),
           которые будут заполнены позже в методе `initialize`.
        3. Создает словари для кэширования данных:
           - `_lesson_cache`: Для хранения информации об уроках.
           - `_subject_cache`: Для предметов.
           - `_student_cache`: Для учеников.
           - `_teacher_cache`: Для учителей.
           - `_schedule_cache`: Для расписания.
           - `_work_types_cache`: Для типов работ (например, контрольная, домашняя).
        4. Определяет словарь `title_to_weight` с весами типов работ (например, экзамен = 10, диктант = 8),
           используемый для анализа важности тестов.

        **Возвращаемые значения**:
        - None: Метод только инициализирует объект, не возвращает данных.

        **Исключения**:
        - Не выбрасывает исключений напрямую, но метод `initialize` может вызвать ошибки,
          если токен недействителен или API недоступен.

        **Пример использования**:
        ```python
        formatter = DnevnikFormatter(token="your_token", debug_mode=True)
        await formatter.initialize()
        ```

        **Замечания**:
        - Токен должен быть защищен, так как он предоставляет доступ к личным данным.
        - Кэши инициализируются пустыми и заполняются в `initialize` или при вызове соответствующих методов.
        - Словарь `title_to_weight` жестко закодирован, но может быть расширен для других типов работ.
        """
        self.token = token
        self.debug_mode = debug_mode
        self.api = None  # Будет инициализирован в асинхронном контексте
        self.person_id = None
        self.school_id = None
        self.group_id = None

        # Инициализация кэшей для оптимизации запросов
        self._lesson_cache = {}
        self._subject_cache = {}
        self._student_cache = {}
        self._teacher_cache = {}
        self._schedule_cache = {}
        self._work_types_cache = {}
        # Словарь весов типов работ для определения важности тестов
        self.title_to_weight = {
            'Административная контрольная работа': 10,
            'Арифметический диктант': 4,
            'Входная контрольная работа': 5,
            'Входной контрольный диктант': 5,
            'Государственная итоговая аттестация': 10,
            'Диагностическая работа': 4,
            'Диктант': 8,
            'Зачет': 8,
            'Интегральный зачет': 3,
            'Итоговая контрольная работа': 9,
            'Контрольная': 9,
            'Контрольное списывание': 7,
            'Контрольный диктант': 9,
            'Лабораторная работа': 7,
            'Математический диктант': 4,
            'Практическая работа': 8,
            'Проверочная работа': 8,
            'Работа с контурными картами': 5,
            'Словарный диктант': 4,
            'Стартовая контрольная работа': 3,
            'Тематическая контрольная работа': 6,
            'Тест': 5,
            'Техника чтения': 5,
            'Устный счет': 4,
            'Экзамен': 10
        }

    async def initialize(self):
        """
        Асинхронно инициализирует клиент API и загружает начальные данные (предметы, ученики, учителя, типы работ).

        **Назначение**:
        Этот метод завершает настройку экземпляра класса, устанавливая соединение с API Дневник.ру
        и заполняя кэши начальными данными, необходимыми для последующей работы.

        **Алгоритм работы**:
        1. Создает асинхронный клиент API с использованием переданного токена.
        2. Выполняет запрос к эндпоинту `/v2/users/me/context` для получения контекста пользователя.
        3. Извлекает ключевые идентификаторы:
           - `person_id`: ID пользователя (ученика, родителя).
           - `school_id`: ID школы.
           - `group_id`: ID учебной группы.
        4. Проверяет, что все идентификаторы получены корректно, иначе выбрасывает исключение.
        5. Логирует успешное получение контекста (если включен debug_mode).
        6. Параллельно загружает начальные данные с помощью `asyncio.gather`:
           - Список предметов (`_load_subjects`).
           - Список учеников (`_load_students`).
           - Список учителей (`_load_teachers`).
           - Типы работ (`_load_work_types`).
        7. Обрабатывает возможные ошибки, логируя их и выбрасывая исключение.

        **Возвращаемые значения**:
        - None: Метод только инициализирует объект.

        **Исключения**:
        - ValueError: Если не удалось извлечь `person_id`, `school_id` или `group_id` из ответа API.
        - Exception: Любые ошибки, связанные с подключением к API (например, неверный токен, недоступность сервера).
          Логируются с подробным описанием.

        **Пример использования**:
        ```python
        formatter = DnevnikFormatter(token="your_token")
        await formatter.initialize()
        print(formatter._subject_cache)  # Выводит кэш предметов
        ```

        **Ошибки и их обработка**:
        - **Неверный токен**: API вернет ошибку авторизации, которая будет залогирована и выброшена как исключение.
          Решение: Проверить токен и получить новый через личный кабинет Дневник.ру.
        - **Отсутствие данных в контексте**: Если API не вернет `personId`, `schools` или `eduGroups`,
          метод выбросит `ValueError`. Решение: Убедиться, что токен имеет доступ к данным пользователя.
        - **Сетевые проблемы**: Ошибки подключения (например, таймаут) будут пойманы и залогированы.
          Решение: Проверить интернет-соединение или повторить попытку позже.
        - **Ошибки загрузки данных**: Если не удается загрузить предметы, учеников или учителей, метод продолжает
          работу, но кэши остаются пустыми, что может повлиять на последующие операции.

        **Замечания**:
        - Метод должен быть вызван до использования других методов, так как он устанавливает критические параметры.
        - Параллельная загрузка данных через `asyncio.gather` ускоряет инициализацию, но увеличивает нагрузку на API.
        - Логирование помогает диагностировать проблемы, особенно если API возвращает неожиданные данные.
        """
        try:
            async with dnevnik.AsyncDiaryAPI(token=self.token) as dn:
                self.api = dn
                self.context = await self.api.get("users/me/context")
                self._log(f"Ответ от /v2/users/me/context:\n{json.dumps(self.context, ensure_ascii=False, indent=2)}")

                # Извлечение идентификаторов из контекста
                self.person_id = str(self.context.get('personId', '0'))
                self.school_id = str(self.context.get('schools', [{}])[0].get('id', '0'))
                self.group_id = str(self.context.get('eduGroups', [{}])[0].get('id_str', '0'))
                #self.group_id = 2255245971833784776 (14 лицей 8К)

                # Проверка корректности идентификаторов
                if not self.person_id or not self.school_id or not self.group_id:
                    raise ValueError("Не удалось получить person_id, school_id или group_id из контекста")

                self._log(f"Инициализация завершена: person_id={self.person_id}, school_id={self.school_id}, group_id={self.group_id}")

                # Параллельная загрузка начальных данных
                await asyncio.gather(
                    self._load_subjects(),
                    self._load_students(),
                    self._load_teachers(),
                    self._load_work_types()
                )
        except Exception as e:
            self._log(f"Ошибка при инициализации: {str(e)}")
            raise

    async def make_ai_request(self, prompt: str) -> str:
        """
        Выполняет асинхронный запрос к API DeepSeek через OpenRouter с заданным промптом.

        **Назначение**:
        Этот метод отправляет текстовый запрос (промпт) к AI для анализа данных, таких как расписание,
        оценки или рейтинги. Используется для получения человекочитаемых выводов или рекомендаций.

        **Параметры**:
        - prompt (str): Текст запроса, который будет отправлен к AI. Обычно форматируется
          с использованием шаблонов из `prompts.json` и включает данные, такие как JSON расписания.

        **Алгоритм работы**:
        1. Создает асинхронный клиент `AsyncOpenAI` с настройками для OpenRouter и указанным API-ключом.
        2. Отправляет запрос к модели `deepseek/deepseek-chat` с промптом в формате чата.
        3. Извлекает текст ответа из первого варианта ответа (`choices[0].message.content`).
        4. Логирует успешное выполнение запроса и длину ответа.
        5. Возвращает ответ AI или сообщение об ошибке, если запрос не удался.

        **Возвращаемые значения**:
        - str: Ответ AI (человекочитаемый текст) или сообщение об ошибке, если запрос не удался.

        **Исключения**:
        - Exception: Любые ошибки, связанные с API (например, неверный ключ, недоступность сервера,
          превышение лимита запросов). Логируются и возвращаются как строка ошибки.

        **Пример использования**:
        ```python
        response = await formatter.make_ai_request("Анализируй расписание: {...}")
        print(response)  # Выводит текст анализа от AI
        ```

        **Ошибки и их обработка**:
        - **Неверный API-ключ**: Вызовет ошибку авторизации, которая будет залогирована и возвращена как строка.
          Решение: Проверить `API_KEY` и заменить на действительный.
        - **Сетевые проблемы**: Таймауты или ошибки соединения будут пойманы и возвращены как строка.
          Решение: Проверить интернет или повторить запрос.
        - **Лимиты API**: Если превышен лимит запросов, API вернет ошибку, которая будет залогирована.
          Решение: Уменьшить частоту запросов или использовать другой ключ.
        - **Некорректный промпт**: Если промпт пустой или некорректный, AI может вернуть неожиданный ответ.
          Решение: Проверить форматирование промпта в `prompts.json`.

        **Замечания**:
        - Метод зависит от внешнего API (OpenRouter/DeepSeek), поэтому его надежность ограничена доступностью сервиса.
        - Ответ AI может быть длинным, что требует проверки при отправке через Telegram (ограничение 4096 символов).
        - Логирование длины ответа помогает оценить объем данных, возвращаемых AI.
        """
        try:
            client = AsyncOpenAI(
                base_url="https://openrouter.ai/api/v1",
                api_key=API_KEY,
            )
            completion = await client.chat.completions.create(
                model="deepseek/deepseek-chat",
                messages=[{"role": "user", "content": prompt}],
                extra_body={}
            )
            response = completion.choices[0].message.content
            self._log(f"AI запрос выполнен: {len(response)} символов")
            return response
        except Exception as e:
            self._log(f"Ошибка при запросе к API DeepSeek: {str(e)}")
            return f"Ошибка при выполнении AI запроса: {str(e)}"

    def clear_schedule_cache(self):
        """
        Очищает кэш расписания, заставляя методы заново загружать данные с API.

        **Назначение**:
        Этот метод используется, когда нужно обновить данные расписания, например, если в Дневник.ру
        были внесены изменения, и кэшированные данные устарели.

        **Алгоритм работы**:
        1. Сбрасывает словарь `_schedule_cache` в пустое состояние.
        2. Логирует действие, если включен `debug_mode`.

        **Возвращаемые значения**:
        - None: Метод только модифицирует внутреннее состояние.

        **Исключения**:
        - Не выбрасывает исключений.

        **Пример использования**:
        ```python
        formatter.clear_schedule_cache()
        schedule = await formatter.get_formatted_schedule(datetime.now())
        ```

        **Ошибки и их обработка**:
        - Ошибок не ожидается, так как метод просто очищает словарь.
        - Если кэш уже пуст, метод не вызывает побочных эффектов.

        **Замечания**:
        - Очистка кэша увеличивает количество запросов к API при следующем вызове методов расписания.
        - Используйте с осторожностью в приложениях с высокой нагрузкой, чтобы не перегружать API.
        """
        self._schedule_cache = {}
        self._log("Кэш расписания очищен")

    def _log(self, message: str):
        """
        Логирует отладочное сообщение в консоль и файл "bot.log", если включен режим отладки.

        **Назначение**:
        Вспомогательный метод для записи сообщений о ходе выполнения программы, ошибках
        и результатах запросов. Используется для диагностики и отладки.

        **Параметры**:
        - message (str): Сообщение для логирования. Может содержать любую информацию,
          например, JSON-ответы API, ошибки или статус операций.

        **Алгоритм работы**:
        1. Проверяет, включен ли `debug_mode`.
        2. Если включен, выводит сообщение в консоль с помощью `print`.

        **Возвращаемые значения**:
        - None: Метод только выводит сообщение.

        **Исключения**:
        - Не выбрасывает исключений.

        **Пример использования**:
        ```python
        formatter._log("Инициализация завершена")
        ```

        **Ошибки и их обработка**:
        - Ошибок не ожидается, так как метод просто выводит текст.
        - Если консоль недоступна (например, в некоторых серверных окружениях), вывод может не отобразиться.

        **Замечания**:
        - Логирование в консоль подходит для разработки, но в продакшене лучше использовать
          библиотеку `logging` с записью в файл или внешний сервис.
        - Сообщения могут быть длинными (например, JSON-ответы), что требует внимания при чтении логов.
        """
        if self.debug_mode:
            print(message)
            
            logging.getLogger(message)

    async def _load_work_types(self):
        """
        Асинхронно загружает и кэширует типы работ школы из API.

        **Назначение**:
        Этот метод получает список типов работ (например, контрольная, домашняя работа), используемых
        в школе, и сохраняет их в кэш для последующего использования в форматировании данных.

        **Алгоритм работы**:
        1. Сбрасывает кэш `_work_types_cache` в пустое состояние.
        2. Проверяет наличие `school_id`. Если отсутствует, выбрасывает исключение.
        3. Выполняет запрос к эндпоинту `/work-types/{school_id}` для получения типов работ.
        4. Для каждого типа извлекает ID и название, сохраняя их в `_work_types_cache`.
        5. Логирует количество загруженных типов и, при включенном `debug_mode`, их содержимое.
        6. В случае ошибки (например, недоступность API) использует запасной набор типов работ
           (жестко закодированный словарь).
        7. Логирует использование запасного набора, если произошла ошибка.

        **Возвращаемые значения**:
        - None: Метод только заполняет кэш.

        **Исключения**:
        - ValueError: Если `school_id` не определен или равен '0'.
        - Exception: Ошибки API (например, неверный токен, недоступность сервера).
          Обрабатываются внутри метода, кэш заполняется запасными данными.

        **Пример использования**:
        ```python
        await formatter._load_work_types()
        print(formatter._work_types_cache)  # Выводит кэш типов работ
        ```

        **Ошибки и их обработка**:
        - **Отсутствие school_id**: Выбрасывается `ValueError`. Решение: Убедиться, что `initialize`
          успешно завершил работу и `school_id` установлен.
        - **Ошибка API**: Например, таймаут или ошибка авторизации. Метод переходит к запасному набору типов.
          Решение: Проверить токен, соединение или повторить запрос.
        - **Пустой ответ API**: Если API вернет пустой список, кэш останется пустым, и метод использует
          запасной набор. Решение: Проверить настройки школы в Дневник.ру.
        - **Некорректные данные**: Если типы работ не содержат ID или названия, они игнорируются.
          Решение: Проверить структуру ответа API.

        **Замечания**:
        - Запасной набор типов работ ограничен и может не покрывать все случаи в школе.
        - Логирование полного кэша в `debug_mode` полезно для проверки, но может быть объемным.
        - Метод вызывается автоматически в `initialize`, поэтому обычно не требует ручного вызова.
        """
        self._work_types_cache = {}
        try:
            if not self.school_id or self.school_id == '0':
                raise ValueError("school_id не определён")
            async with dnevnik.AsyncDiaryAPI(token=self.token) as dn:
                work_types = await dn.get(f"work-types/{self.school_id}")
                for wt in work_types:
                    work_type_id = str(wt.get('id', '0'))
                    work_type_name = wt.get('title', 'Неизвестный тип').strip()
                    if work_type_id and work_type_name:
                        self._work_types_cache[work_type_id] = work_type_name
                self._log(f"Загружено типов работ: {len(self._work_types_cache)}")
                if self.debug_mode:
                    self._log(f"Типы работ:\n{json.dumps(self._work_types_cache, ensure_ascii=False, indent=2)}")
        except Exception as e:
            self._log(f"Ошибка при загрузке типов работ: {str(e)}")
            self._work_types_cache = {
                'CommonWork': 'Работа на уроке',
                'DefaultNewLessonWork': 'Работа на уроке',
                'LessonTestWork': 'Контрольная работа',
                'Homework': 'Домашняя работа',
                'CreativeWork': 'Творческая работа'
            }
            self._log(f"Использован запасной набор типов работ: {len(self._work_types_cache)}")

    async def _read_prompts(self) -> Dict[str, str]:
        """
        Асинхронно читает промпты для AI-анализа из файла prompts.json.

        **Назначение**:
        Этот метод загружает шаблоны запросов для AI, используемые в методе `analyze_data`.
        Промпты определяют, как данные (расписание, оценки, рейтинги) будут анализироваться AI.

        **Алгоритм работы**:
        1. Открывает файл `prompts.json` асинхронно с помощью `aiofiles`.
        2. Читает содержимое файла и парсит его как JSON.
        3. Извлекает промпты для ключей 'weeks', 'marks', 'ranking', игнорируя другие ключи.
        4. Логирует успешную загрузку и список ключей промптов.
        5. В случае ошибок (файл не найден, некорректный JSON) логирует проблему и выбрасывает исключение.

        **Возвращаемые значения**:
        - Dict[str, str]: Словарь с промптами, где ключи — типы анализа ('weeks', 'marks', 'ranking'),
          а значения — текстовые шаблоны.

        **Исключения**:
        - FileNotFoundError: Если файл `prompts.json` не найден в текущей директории.
        - Exception: Ошибки парсинга JSON (например, некорректный формат файла).
          Логируются и выбрасываются для обработки выше.

        **Пример использования**:
        ```python
        prompts = await formatter._read_prompts()
        print(prompts['marks'])  # Выводит промпт для анализа оценок
        ```

        **Ошибки и их обработка**:
        - **Файл не найден**: Выбрасывается `FileNotFoundError`. Решение: Убедиться, что `prompts.json`
          существует в той же директории, что и скрипт.
        - **Некорректный JSON**: Если файл содержит ошибки синтаксиса, выбрасывается `Exception`.
          Решение: Проверить и исправить `prompts.json` с помощью JSON-валидатора.
        - **Отсутствие ключей**: Если в файле нет ожидаемых ключей ('weeks', 'marks', 'ranking'),
          метод вернет пустые строки для них. Решение: Добавить недостающие промпты в файл.

        **Замечания**:
        - Файл `prompts.json` должен быть в формате:
          ```json
          {
              "weeks": {"prompt": "Анализируй расписание: {schedule_data}"},
              "marks": {"prompt": "Анализируй оценки: {marks_data}"},
              "ranking": {"prompt": "Анализируй рейтинг: {ranking_data}"}
          }
          ```
        - Метод асинхронный из-за использования `aiofiles`, что соответствует общей архитектуре класса.
        - Логирование ключей помогает проверить, что файл загружен корректно.
        """
        try:
            async with aiofiles.open("prompts.json", 'r', encoding='utf-8') as f:
                content = await f.read()
                prompts_data = json.loads(content)
            prompts = {
                key: data.get("prompt", "") for key, data in prompts_data.items()
            }
            self._log(f"Промпты успешно загружены из prompts.json: {list(prompts.keys())}")
            return prompts
        except FileNotFoundError:
            self._log("Ошибка: Файл prompts.json не найден")
            raise
        except Exception as e:
            self._log(f"Ошибка при чтении prompts.json: {str(e)}")
            raise

    async def _load_subjects(self):
        """
        Асинхронно загружает и кэширует предметы учебной группы из API.

        **Назначение**:
        Этот метод получает список учебных предметов, доступных для группы, и сохраняет их в кэш
        для использования в других методах, таких как форматирование расписания или оценок.

        **Алгоритм работы**:
        1. Сбрасывает кэш `_subject_cache` в пустое состояние.
        2. Пытается загрузить предметы через эндпоинт `/edu-groups/{group_id}/subjects`.
        3. Для каждого предмета извлекает ID и название, сохраняя их в `_subject_cache`.
        4. Логирует количество загруженных предметов.
        5. Если запрос не удался (например, из-за ошибки API), переходит к запасному варианту:
           - Устанавливает учебный год (с 1 сентября текущего или предыдущего года до 31 августа).
           - Запрашивает расписание за год через `/persons/{person_id}/groups/{group_id}/schedules`.
           - Извлекает предметы из расписания (ID и название).
           - Если за год предметы не найдены, пробует последние 30 дней.
        6. Логирует успешную загрузку или ошибки, включая запасные попытки.
        7. При включенном `debug_mode` выводит полный кэш предметов.

        **Возвращаемые значения**:
        - None: Метод только заполняет кэш.

        **Исключения**:
        - Exception: Ошибки API (например, неверный токен, недоступность сервера).
          Обрабатываются внутри метода, кэш заполняется из расписания или остается пустым.

        **Пример использования**:
        ```python
        await formatter._load_subjects()
        print(formatter._subject_cache)  # Выводит кэш предметов
        ```

        **Ошибки и их обработка**:
        - **Ошибка API при основном запросе**: Например, ошибка авторизации или недоступность сервера.
          Метод переходит к запасному варианту (расписание). Решение: Проверить токен и соединение.
        - **Ошибка загрузки расписания**: Если расписание за год или 30 дней не удается загрузить,
          кэш остается пустым. Решение: Убедиться, что `person_id` и `group_id` корректны.
        - **Пустой ответ API**: Если предметы не найдены, кэш останется пустым, что может повлиять
          на другие методы. Решение: Проверить настройки группы в Дневник.ру.
        - **Некорректные данные**: Если предметы не содержат ID или названия, они игнорируются.
          Решение: Проверить структуру ответа API.

        **Замечания**:
        - Запасной вариант загрузки из расписания менее надежен, так как зависит от наличия уроков.
        - Период загрузки расписания (год или 30 дней) может не охватывать все предметы.
        - Метод вызывается автоматически в `initialize`, поэтому редко требует ручного вызова.
        """
        self._subject_cache = {}
        try:
            async with dnevnik.AsyncDiaryAPI(token=self.token) as dn:
                subjects = await dn.get(f"edu-groups/{self.group_id}/subjects")
                for subject in subjects:
                    subject_id = str(subject.get('id'))
                    subject_name = subject.get('name', 'Неизвестный предмет').strip()
                    if subject_id and subject_name:
                        self._subject_cache[subject_id] = subject_name
                self._log(f"Загружено предметов из /edu-groups/subjects: {len(self._subject_cache)}")
        except Exception as e:
            self._log(f"Ошибка при загрузке предметов из /edu-groups/subjects: {str(e)}")
            try:
                now = datetime.now()
                start_date = now.replace(month=9, day=1, hour=0, minute=0, second=0, microsecond=0)
                if start_date > now:
                    start_date = start_date.replace(year=start_date.year - 1)
                end_date = start_date.replace(year=start_date.year + 1, month=8, day=31, hour=23, minute=59, second=59, microsecond=999999)
                max_attempts = 1
                attempt = 1
                schedule = {'days': []}
                async with dnevnik.AsyncDiaryAPI(token=self.token) as dn:
                    while attempt <= max_attempts:
                        try:
                            schedule = await dn.get(
                                f"persons/{self.person_id}/groups/{self.group_id}/schedules",
                                params={
                                    "startDate": start_date.strftime("%Y-%m-%dT%H:%M:%S"),
                                    "endDate": end_date.strftime("%Y-%m-%dT%H:%M:%S")
                                }
                            )
                            break
                        except Exception as e:
                            self._log(f"Попытка {attempt}/{max_attempts} не удалась: Ошибка при загрузке расписания: {str(e)}")
                            attempt += 1
                    for day in schedule.get('days', []):
                        for subject in day.get('subjects', []):
                            subject_id = str(subject.get('id'))
                            subject_name = subject.get('name', 'Неизвестный предмет').strip()
                            if subject_id and subject_name:
                                self._subject_cache[subject_id] = subject_name
                    self._log(f"Загружено предметов из расписания за год: {len(self._subject_cache)}")
                    if not self._subject_cache:
                        self._log("Предметы не найдены за год, пробую последние 30 дней")
                        start_date = now - timedelta(days=30)
                        end_date = now
                        schedule = await dn.get(
                            f"persons/{self.person_id}/groups/{self.group_id}/schedules",
                            params={
                                "startDate": start_date.strftime("%Y-%m-%dT%H:%M:%S"),
                                "endDate": end_date.strftime("%Y-%m-%dT%H:%M:%S")
                            }
                        )
                        for day in schedule.get('days', []):
                            for subject in day.get('subjects', []):
                                subject_id = str(subject.get('id'))
                                subject_name = subject.get('name', 'Неизвестный предмет').strip()
                                if subject_id and subject_name:
                                    self._subject_cache[subject_id] = subject_name
                        self._log(f"Загружено предметов из расписания за 30 дней: {len(self._subject_cache)}")
            except Exception as e:
                self._log(f"Ошибка при загрузке предметов из расписания: {str(e)}")
        if self.debug_mode:
            self._log(f"Предметы:\n{json.dumps(self._subject_cache, ensure_ascii=False, indent=2)}")

    async def _load_students(self):
        """
        Асинхронно загружает и кэширует список учеников учебной группы из API.

        **Назначение**:
        Этот метод получает данные об учениках группы, сохраняя их ID и имена в кэш
        для использования в методах, таких как `get_class_ranking` или `get_subject_ranking`.

        **Алгоритм работы**:
        1. Выполняет запрос к методу `get_groups_pupils` API с использованием `group_id`.
        2. Для каждого ученика извлекает ID и краткое имя (`shortName`).
        3. Сохраняет данные в `_student_cache`, где ключ — ID, а значение — имя.
        4. Логирует количество загруженных учеников.
        5. В случае ошибки (например, недоступность API) логирует проблему и устанавливает
           пустой кэш.

        **Возвращаемые значения**:
        - None: Метод только заполняет кэш.

        **Исключения**:
        - Exception: Ошибки API (например, неверный токен, недоступность сервера).
          Обрабатываются внутри метода, кэш остается пустым.

        **Пример использования**:
        ```python
        await formatter._load_students()
        print(formatter._student_cache)  # Выводит кэш учеников
        ```

        **Ошибки и их обработка**:
        - **Ошибка API**: Например, ошибка авторизации или недоступность сервера.
          Кэш остается пустым. Решение: Проверить токен и соединение.
        - **Пустой ответ API**: Если группа не содержит учеников, кэш будет пустым.
          Решение: Проверить настройки группы в Дневник.ру.
        - **Некорректные данные**: Если ученик не имеет ID или имени, он игнорируется.
          Решение: Проверить структуру ответа API.

        **Замечания**:
        - Метод вызывается автоматически в `initialize`, поэтому редко требует ручного вызова.
        - Пустой кэш может повлиять на методы, зависящие от списка учеников, например, `get_class_ranking`.
        - Логирование помогает проверить, сколько учеников загружено, что полезно для отладки.
        """
        try:
            async with dnevnik.AsyncDiaryAPI(token=self.token) as dn:
                students = await dn.get_groups_pupils(self.group_id)
                for student in students:
                    student_id = str(student.get('id'))
                    student_name = student.get('shortName', 'Неизвестный')
                    if student_id and student_name:
                        self._student_cache[student_id] = student_name
                self._log(f"Загружено учеников: {len(self._student_cache)}")
        except Exception as e:
            self._log(f"Ошибка при загрузке учеников: {str(e)}")
            self._student_cache = {}

    async def _load_teachers(self):
        """
        Асинхронно загружает и кэширует список учителей школы из API.

        **Назначение**:
        Этот метод получает данные об учителях школы, сохраняя их ID, имена, предметы и другую
        информацию в кэш для использования в методах, таких как `get_group_teachers`.

        **Алгоритм работы**:
        1. Выполняет запрос к эндпоинту `/schools/{school_id}/teachers`.
        2. Для каждого учителя извлекает:
           - ID (`Id`).
           - Краткое имя (`ShortName`).
           - Полное имя (`FirstName`, `MiddleName`, `LastName`).
           - Список предметов (`Subjects`).
           - Email (`Email`).
           - Должность (`NameTeacherPosition`).
        3. Сохраняет данные в `_teacher_cache` как словарь с этими полями.
        4. Логирует количество загруженных учителей.
        5. В случае ошибки (например, недоступность API) логирует проблему и устанавливает
           пустой кэш.

        **Возвращаемые значения**:
        - None: Метод только заполняет кэш.

        **Исключения**:
        - Exception: Ошибки API (например, неверный токен, недоступность сервера).
          Обрабатываются внутри метода, кэш остается пустым.

        **Пример использования**:
        ```python
        await formatter._load_teachers()
        print(formatter._teacher_cache)  # Выводит кэш учителей
        ```

        **Ошибки и их обработка**:
        - **Ошибка API**: Например, ошибка авторизации или недоступность сервера.
          Кэш остается пустым. Решение: Проверить токен и соединение.
        - **Пустой ответ API**: Если в школе нет учителей (маловероятно), кэш будет пустым.
          Решение: Проверить настройки школы в Дневник.ру.
        - **Некорректные данные**: Если учитель не имеет ID, он игнорируется.
          Решение: Проверить структуру ответа API.

        **Замечания**:
        - Метод вызывается автоматически в `initialize`, поэтому редко требует ручного вызова.
        - Пустой кэш может повлиять на методы, зависящие от списка учителей, например, `get_group_teachers`.
        - Полное имя формируется из трех полей, что может привести к пустой строке, если данные отсутствуют.
        """
        try:
            async with dnevnik.AsyncDiaryAPI(token=self.token) as dn:
                teachers = await dn.get(f"schools/{self.school_id}/teachers")
                for teacher in teachers:
                    teacher_id = str(teacher.get('Id'))
                    if not teacher_id:
                        continue
                    teacher_name = teacher.get('ShortName', 'Неизвестно')
                    full_name = f"{teacher.get('FirstName', '')} {teacher.get('MiddleName', '')} {teacher.get('LastName', '')}".strip()
                    self._teacher_cache[teacher_id] = {
                        'shortName': teacher_name,
                        'fullName': full_name,
                        'subjects': teacher.get('Subjects', 'Неизвестно'),
                        'email': teacher.get('Email', ''),
                        'position': teacher.get('NameTeacherPosition', 'Неизвестно')
                    }
                self._log(f"Загружено учителей: {len(self._teacher_cache)}")
        except Exception as e:
            self._log(f"Ошибка при загрузке учителей: {str(e)}")
            self._teacher_cache = {}

    async def _get_lesson_info(self, lesson_id: str, force_refresh: bool = False) -> Optional[Dict]:
        """
        Асинхронно получает информацию об уроке по его ID, используя кэш или API.

        **Назначение**:
        Этот метод извлекает подробные данные об уроке (например, тема, предмет, работы) по его ID,
        минимизируя запросы к API за счет кэширования.

        **Параметры**:
        - lesson_id (str): Идентификатор урока. Должен быть непустым и корректным.
        - force_refresh (bool, optional): Если True, игнорирует кэш и запрашивает данные заново.
          Полезно для обновления устаревших данных. По умолчанию False.

        **Алгоритм работы**:
        1. Проверяет корректность `lesson_id`. Если пустой или '0', возвращает пустой словарь.
        2. Проверяет, есть ли данные в кэше `_lesson_cache` и не требуется ли обновление (`force_refresh`).
        3. Если данные отсутствуют или требуется обновление:
           - Выполняет запрос к эндпоинту `get_lesson_info` с преобразованным `lesson_id` в int.
           - Сохраняет результат в кэш.
           - Логирует успешную загрузку с названием урока.
        4. В случае ошибки (например, недоступность API) логирует проблему и сохраняет пустой словарь в кэш.
        5. Возвращает данные из кэша или пустой словарь, если урок не найден.

        **Возвращаемые значения**:
        - Optional[Dict]: Словарь с данными урока (например, `title`, `subject`, `works`) или
          пустой словарь, если урок не найден или ID некорректен.

        **Исключения**:
        - Exception: Ошибки API (например, неверный токен, недоступность сервера).
          Обрабатываются внутри метода, возвращается пустой словарь.

        **Пример использования**:
        ```python
        lesson = await formatter._get_lesson_info("123456")
        print(lesson.get('title'))  # Выводит тему урока
        ```

        **Ошибки и их обработка**:
        - **Некорректный lesson_id**: Если ID пустой или '0', возвращается пустой словарь.
          Решение: Проверить правильность ID урока.
        - **Ошибка API**: Например, ошибка авторизации или недоступность сервера.
          Возвращается пустой словарь. Решение: Проверить токен и соединение.
        - **Отсутствие данных**: Если урок не существует, API может вернуть пустой ответ,
          который кэшируется как пустой словарь. Решение: Проверить ID урока в Дневник.ру.

        **Замечания**:
        - Кэширование снижает нагрузку на API, но может вернуть устаревшие данные, если урок изменился.
        - Параметр `force_refresh` полезен для принудительного обновления, но увеличивает запросы.
        - Логирование названия урока помогает отслеживать, какие уроки загружаются.
        """
        if not lesson_id or lesson_id == '0':
            self._log(f"Некорректный lesson_id: {lesson_id}")
            return {}
        if force_refresh or lesson_id not in self._lesson_cache:
            try:
                async with dnevnik.AsyncDiaryAPI(token=self.token) as dn:
                    lesson_data = await dn.get_lesson_info(int(lesson_id))
                    self._lesson_cache[lesson_id] = lesson_data
                    self._log(f"Загружен урок {lesson_id}: {lesson_data.get('title', 'Без названия')}")
            except Exception as e:
                self._log(f"Ошибка при загрузке урока {lesson_id}: {str(e)}")
                self._lesson_cache[lesson_id] = {}
        return self._lesson_cache.get(lesson_id, {})
    

    async def _get_work_marks_by_id(self, work_id: int) -> List[Dict[str, str]]:
        """
        Получает список учеников и их оценок для указанной работы асинхронно.
        
        Args:
            work_id (int): ID работы.
            
        Returns:
            List[Dict[str, str]]: Список словарей с полями:
                - name (str): Краткое имя ученика.
                - mark (str): Оценка.
                
        Raises:
            ValueError: Если work_id некорректен.
            Exception: При сетевых ошибках (логируется).
        """
        result = []
        try:
            # Проверяем наличие учеников в кэше
            if not self._student_cache:
                self._log("Student cache is empty, cannot fetch work marks")
                return result

            self._log(f"Запрос оценок для work_id={work_id}, учеников в кэше: {len(self._student_cache)}")
            async with dnevnik.AsyncDiaryAPI(token=self.token) as dn:
                for student_id, student_name in self._student_cache.items():
                    try:
                        # Пытаемся получить оценки, учитывая возможную корутину
                        marks_response = await dn.get_person_work_marks(person_id=student_id, work_id=work_id)
                        marks_response = await marks_response


                        # Обрабатываем каждую оценку
                        for mark in marks_response:
                            mark_value = mark.get("value", "")
                            if mark_value:
                                result.append({
                                    "name": student_name,
                                    "mark": mark_value
                                })
                    except Exception as e:
                        self._log(f"Ошибка при запросе оценок для person_id={student_id}: {e}")
                        continue
            
            self._log(f"Fetched marks for work_id={work_id}: {len(result)} records")
            return result
            
        except ValueError as e:
            self._log(f"Invalid work_id={work_id}: {e}")
            raise
        except Exception as e:
            self._log(f"Error fetching marks for work_id={work_id}: {e}")
            return result


    async def _get_formatted_schedule_day(self, date: datetime) -> List[Dict[str, any]]:
        """
        Асинхронно получает и форматирует расписание уроков для указанной даты.

        **Назначение**:
        Этот метод извлекает расписание на конкретный день, форматируя данные в удобный для
        использования вид, включая информацию об уроках, учителях, домашних заданиях и оценках.

        **Параметры**:
        - date (datetime): Дата, для которой требуется расписание. Формат должен включать
          год, месяц и день.

        **Алгоритм работы**:
        1. Форматирует дату в строку (`YYYY-MM-DD`) для проверки кэша.
        2. Проверяет, есть ли расписание в `_schedule_cache`. Если есть, возвращает кэшированные данные.
        3. Выполняет запрос к эндпоинту `/persons/{person_id}/groups/{group_id}/schedules`
           с параметрами `startDate` и `endDate` для указанного дня.
        4. Обрабатывает ответ API:
           - Извлекает предметы, учителей, домашние задания, работы, типы работ, статусы уроков,
             оценки и файлы.
           - Создает словари для быстрого доступа к этим данным по ID.
        5. Для каждого урока в расписании:
           - Извлекает ID, номер урока, предмет, учителей, класс, время, статус и посещаемость.
           - Форматирует домашние задания, включая текст и файлы.
           - Собирает данные об оценках, включая тип работы и настроение.
           - Добавляет информацию в список `formatted_schedule`.
        6. Сортирует уроки по номеру урока.
        7. Сохраняет результат в кэш `_schedule_cache`.
        8. Логирует количество уроков и ошибки, если они возникают.
        9. Возвращает отформатированный список уроков.

        **Возвращаемые значения**:
        - List[Dict[str, any]]: Список словарей, где каждый словарь содержит информацию об уроке:
          - `time`: Время урока.
          - `subject`: Название предмета.
          - `homework`: Текст домашнего задания.
          - `files`: Список файлов домашнего задания.
          - `title`: Тема урока.
          - `teacher`: Имя учителя.
          - `mark_details`: Список оценок с типами работ.
          - `classroom`: Место проведения (здание, кабинет, этаж).
          - `lesson_id`: ID урока.
          - `works`: Список типов работ.
          - `lesson_number`: Номер урока.
          - `lesson_status`: Статус урока.
          - `attendance`: Статус посещаемости.
          - `is_important`: Флаг важности домашнего задания.
          - `sent_date`: Дата отправки домашнего задания.

        **Исключения**:
        - Exception: Ошибки API (например, неверный токен, недоступность сервера).
          Обрабатываются внутри метода, возвращается пустой список.

        **Пример использования**:
        ```python
        schedule = await formatter._get_formatted_schedule_day(datetime(2025, 5, 21))
        for lesson in schedule:
            print(f"{lesson['time']} - {lesson['subject']}: {lesson['homework']}")
        ```

        **Ошибки и их обработка**:
        - **Ошибка API**: Например, ошибка авторизации или недоступность сервера.
          Возвращается пустой список. Решение: Проверить токен и соединение.
        - **Пустой ответ API**: Если расписание на день отсутствует, возвращается пустой список.
          Решение: Проверить, есть ли уроки в Дневник.ру на эту дату.
        - **Некорректные данные**: Если данные урока (например, предмет или учитель) отсутствуют,
          используются значения по умолчанию ('Неизвестно'). Решение: Проверить структуру ответа API.
        - **Дублирующиеся уроки**: Уроки с одинаковым ID игнорируются для предотвращения дублирования.
          Решение: Проверить настройки расписания в Дневник.ру.

        **Замечания**:
        - Кэширование ускоряет повторные запросы за ту же дату, но требует вызова `clear_schedule_cache`
          при изменении расписания.
        - Форматирование включает множество деталей, что делает метод универсальным для отображения
          в интерфейсах (например, Telegram).
        - Логирование количества уроков помогает отслеживать, насколько заполнено расписание.
        """
        date_str = date.strftime('%Y-%m-%d')
        if date_str in self._schedule_cache:
            self._log(f"Использую кэшированное расписание для {date_str}")
            return self._schedule_cache[date_str]

        try:
            async with dnevnik.AsyncDiaryAPI(token=self.token) as dn:
                schedule = await dn.get(
                    f"persons/{self.person_id}/groups/{self.group_id}/schedules",
                    params={
                        "startDate": date.strftime("%Y-%m-%dT00:00:00"),
                        "endDate": date.strftime("%Y-%m-%dT23:59:59")
                    }
                )
        except Exception as e:
            self._log(f"Ошибка при получении расписания: {str(e)}")
            self._schedule_cache[date_str] = []
            return []

        if not schedule.get('days'):
            self._log(f"Нет данных расписания для {date_str}")
            self._schedule_cache[date_str] = []
            return []

        formatted_schedule = []
        seen_lesson_ids = set()
        for day in schedule.get('days', []):
            if not day.get('date', '').startswith(date_str):
                continue

            subjects = {str(s['id']): s['name'] for s in day.get('subjects', [])}
            for subject_id, subject_name in subjects.items():
                if subject_id not in self._subject_cache:
                    self._subject_cache[subject_id] = subject_name
                    self._log(f"Добавлен предмет в _subject_cache: {subject_id} -> {subject_name}")

            teachers = {str(t['person']['id']): t['person']['shortName'] for t in day.get('teachers', [])}
            homeworks = {str(w['id']): w for w in day.get('homeworks', [])}
            works = {str(w['id']): w for w in day.get('works', [])}
            work_types = {str(wt['id']): wt['name'] for wt in day.get('workTypes', [])}
            lesson_logs = {str(l['lesson_str']): l['status'] for l in day.get('lessonLogEntries', []) 
                          if str(l['person_str']) == self.person_id}
            marks = {str(m['work']): m for m in day.get('marks', []) if str(m['person']) == self.person_id}
            files = {str(f['id']): f for f in day.get('files', [])}

            for lesson in day.get('lessons', []):
                lesson_id = str(lesson.get('id', '0'))
                if lesson_id in seen_lesson_ids:
                    self._log(f"Пропущен дублирующийся урок ID={lesson_id}")
                    continue
                seen_lesson_ids.add(lesson_id)

                subject_id = str(lesson.get('subjectId', '0'))
                if subject_id not in subjects:
                    self._log(f"Пропущен урок ID={lesson_id}: subject_id={subject_id} отсутствует")
                    continue

                lesson_number = lesson.get('number', 0)
                subject_name = subjects.get(subject_id, 'Неизвестный предмет')
                teacher_ids = lesson.get('teachers', [])
                teacher_name = ', '.join(teachers.get(str(t), 'Неизвестно') for t in teacher_ids) or 'Неизвестно'

                floor = lesson.get('floor', '')
                classroom = f"{lesson.get('building', 'Не указан')} {lesson.get('place', 'Не указан')}".strip()
                if classroom == "Не указан Не указан":
                    classroom = "Не указан"
                if floor:
                    classroom += f", этаж {floor}"

                lesson_title = lesson.get('title', subject_name) or subject_name
                time_str = lesson.get('hours', 'Неизвестное время')
                lesson_status = lesson.get('status', 'Неизвестно')
                attendance = lesson_logs.get(lesson_id, 'Присутствовал')

                for t in day.get('teachers', []):
                    teacher_id = str(t['person']['id'])
                    if teacher_id not in self._teacher_cache:
                        self._teacher_cache[teacher_id] = {
                            'shortName': t['person']['shortName'],
                            'fullName': t['person'].get('fullName', ''),
                            'subjects': 'Неизвестно',
                            'email': '',
                            'position': 'Неизвестно'
                        }

                lesson_works = []
                for work_id in lesson.get('works', []):
                    work_id_str = str(work_id)
                    work = works.get(work_id_str)
                    if work:
                        work_type_id = str(work.get('workType', '0'))
                        work_type_name = work_types.get(work_type_id, self._work_types_cache.get(work_type_id, 'Неизвестный тип'))
                        lesson_works.append({
                            'work': work_type_name
                        })

                homework_text = []
                homework_files = []
                is_important = False
                sent_dates = []
                for work_id in lesson.get('works', []):
                    work_id_str = str(work_id)
                    hw = homeworks.get(work_id_str)
                    if not hw or hw.get('type') != 'Homework':
                        continue
                    text = (hw.get('text') or '').strip()
                    if text and text.lower() not in ['нет', 'нет задания', '-', '.']:
                        homework_text.append(text)
                    for file_id in hw.get('files', []):
                        file = files.get(str(file_id))
                        if file:
                            homework_files.append(f"{file.get('name', 'Файл')} ({file.get('downloadUrl', '')})")
                    is_important = is_important or hw.get('isImportant', False)
                    sent_date = hw.get('sentDate')
                    if sent_date:
                        sent_dates.append(sent_date)

                if not homework_text and not homework_files:
                    homework_text = ['Нет задания']
                homework = '\n'.join(homework_text)
                homework_files = list(set(homework_files))
                sent_date = max(sent_dates, default=None) if sent_dates else None

                mark_details = []
                for work_id in lesson.get('works', []):
                    work_id_str = str(work_id)
                    if work_id_str in marks:
                        mark = marks[work_id_str]
                        work = works.get(work_id_str, {})
                        work_type_id = str(work.get('workType', '0'))
                        mark_details.append({
                            'value': mark.get('value', ''),
                            'work_type': work_types.get(work_type_id, self._work_types_cache.get(work_type_id, 'Неизвестный тип')),
                            'mood': mark.get('mood', 'Нет'),
                            'lesson_title': lesson_title
                        })

                formatted_schedule.append({
                    'time': time_str,
                    'subject': subject_name,
                    'homework': homework,
                    'files': homework_files,
                    'title': lesson_title,
                    'teacher': teacher_name,
                    'mark_details': mark_details,
                    'classroom': classroom,
                    'lesson_id': lesson_id,
                    'works': lesson_works,
                    'lesson_number': lesson_number,
                    'lesson_status': lesson_status,
                    'attendance': attendance,
                    'is_important': is_important,
                    'sent_date': sent_date
                })

        formatted_schedule = sorted(formatted_schedule, key=lambda x: x['lesson_number'])
        self._schedule_cache[date_str] = formatted_schedule
        self._log(f"Итоговое расписание за {date_str}: {len(formatted_schedule)} уроков")
        return formatted_schedule

    async def get_formatted_schedule(self, start_date: datetime, end_date: Optional[datetime] = None) -> Dict[str, List[Dict[str, any]]] | List[Dict[str, any]]:
        """
        Асинхронно получает расписание уроков для одной даты или диапазона дат.

        **Назначение**:
        Этот метод предоставляет удобный интерфейс для получения расписания, вызывая
        `_get_formatted_schedule_day` для каждой даты в диапазоне или для одной даты.

        **Параметры**:
        - start_date (datetime): Начальная дата расписания.
        - end_date (datetime, optional): Конечная дата. Если None, возвращается расписание
          только для `start_date`.

        **Алгоритм работы**:
        1. Если `end_date` не указан, вызывает `_get_formatted_schedule_day` для `start_date`
           и возвращает результат (список уроков).
        2. Проверяет, что `end_date` не раньше `start_date`. Если это так, выбрасывает исключение.
        3. Создает словарь `result`, где ключи — даты в формате `YYYY-MM-DD`, а значения —
           списки уроков.
        4. Итерируется по датам от `start_date` до `end_date`, вызывая `_get_formatted_schedule_day`
           для каждой даты.
        5. Возвращает словарь с расписанием для всех дат.

        **Возвращаемые значения**:
        - Dict[str, List[Dict[str, any]]] | List[Dict[str, any]]: Если указан `end_date`,
          возвращается словарь с расписанием по датам. Если `end_date` None, возвращается список
          уроков для `start_date`.

        **Исключения**:
        - ValueError: Если `end_date` раньше `start_date`.
        - Exception: Ошибки API обрабатываются в `_get_formatted_schedule_day`, поэтому
          метод возвращает пустые списки для проблемных дат.

        **Пример использования**:
        ```python
        # Для одной даты
        schedule = await formatter.get_formatted_schedule(datetime(2025, 5, 21))
        print(schedule)
        # Для диапазона
        schedule = await formatter.get_formatted_schedule(
            datetime(2025, 5, 21), datetime(2025, 5, 23)
        )
        print(schedule)
        ```

        **Ошибки и их обработка**:
        - **Некорректные даты**: Если `end_date` раньше `start_date`, выбрасывается `ValueError`.
          Решение: Убедиться, что даты указаны правильно.
        - **Ошибка API**: Обрабатывается в `_get_formatted_schedule_day`, возвращается пустой
          список для проблемной даты. Решение: Проверить токен и соединение.
        - **Пустое расписание**: Если для даты нет уроков, возвращается пустой список.
          Решение: Проверить наличие уроков в Дневник.ру.

        **Замечания**:
        - Метод удобен для Telegram-ботов, где нужно показать расписание за день или неделю.
        - Кэширование в `_get_formatted_schedule_day` снижает нагрузку на API.
        - Возвращаемый формат универсален для отображения в интерфейсах.
        """
        if end_date is None:
            return await self._get_formatted_schedule_day(start_date)
        if end_date < start_date:
            raise ValueError("end_date не может быть раньше start_date")
        result = {}
        current_date = start_date
        while current_date <= end_date:
            date_str = current_date.strftime('%Y-%m-%d')
            result[date_str] = await self._get_formatted_schedule_day(current_date)
            current_date += timedelta(days=1)
        return result

    async def get_last_marks(self, count: int = 5, subject_id: Optional[int] = None) -> List[Dict[str, any]]:
        """
        Асинхронно получает последние оценки ученика, с возможностью фильтрации по предмету.

        Args:
            count (int, optional): Количество оценок. Defaults to 5.
            subject_id (Optional[int], optional): ID предмета. Defaults to None.

        Returns:
            List[Dict[str, any]]: Список словарей с полями:
                - subject (str): Название предмета.
                - work_type (str): Тип работы.
                - lesson_title (str): Тема урока.
                - mark (str): Оценка.
                - class_distribution (dict): Распределение оценок:
                    - mark (str): Оценка.
                    - count (int): Количество.
                    - student_marks (List[Dict[str, str]]): Список учеников с оценками:
                        - name (str): Краткое имя.
                        - mark (str): Оценка.
                - date (str): Дата оценки (DD.MM.YYYY).

        Raises:
            ValueError: Если count <= 0.
        """
        if count <= 0:
            raise ValueError("Count must be positive")

        result = []
        try:
            if not self._student_cache:
                self._log("Student cache is empty, attempting to reload")
                await self._load_students()
                if not self._student_cache:
                    self._log("Failed to load students, class_distribution will be empty")

            if not self._subject_cache:
                self._log("Subject cache is empty, attempting to reload")
                await self._load_subjects()

            if subject_id and str(subject_id) not in self._subject_cache:
                self._log(f"Предупреждение: subject_id={subject_id} отсутствует в _subject_cache. Фильтр отключён.")
                subject_id = None

            async with dnevnik.AsyncDiaryAPI(token=self.token) as dn:
                end_date = datetime.now()
                start_date = end_date - timedelta(days=90)
                marks = await dn.get_person_marks(self.person_id, self.school_id, start_date, end_date)
                self._log(f"Получено оценок: {len(marks)}")

            def parse_mark_date(date_str):
                try:
                    return datetime.strptime(date_str, '%Y-%m-%dT%H:%M:%S.%f')
                except ValueError:
                    try:
                        return datetime.strptime(date_str, '%Y-%m-%dT%H:%M:%S')
                    except ValueError:
                        try:
                            return datetime.strptime(date_str, '%Y-%m-%d')
                        except ValueError:
                            self._log(f"Некорректный формат даты оценки: {date_str}")
                            return datetime.now()

            # Фильтрация по дате (последние 90 дней)
            end_date = datetime.now()
            start_date = end_date - timedelta(days=90)
            filtered_marks = [
                mark for mark in marks
                if parse_mark_date(mark.get('date', '1970-01-01')) >= start_date
            ]
            self._log(f"Отфильтровано оценок за последние 90 дней: {len(filtered_marks)}")

            filtered_marks.sort(key=lambda x: parse_mark_date(x.get('date', '1970-01-01')), reverse=True)
            filtered_marks = filtered_marks[:count]

            for mark in filtered_marks:
                lesson_id = str(mark.get('lesson_str', '0'))
                work_id = str(mark.get('work_str', '0'))
                mark_date = parse_mark_date(mark.get('date', '1970-01-01')).date()
                lesson_data = await self._get_lesson_info(lesson_id)
                subject_id_from_mark = str(lesson_data.get('subject', {}).get('id')) if lesson_data.get('subject') else None

                if subject_id and subject_id_from_mark and str(subject_id) != subject_id_from_mark:
                    self._log(f"Пропущена оценка для урока {lesson_id}: subject_id={subject_id_from_mark} не совпадает с {subject_id}")
                    continue

                mark_info = {
                    'subject': self._subject_cache.get(subject_id_from_mark, 'Неизвестный предмет') if subject_id_from_mark else 'Неизвестный предмет',
                    'work_type': 'Неизвестный тип',
                    'lesson_title': lesson_data.get('title', 'Неизвестная тема') or 'Неизвестная тема',
                    'mark': mark.get('value', 'Нет оценки'),
                    'class_distribution': {},
                    'date': mark_date.strftime('%d.%m.%Y')
                }

                if lesson_data.get('works'):
                    for work in lesson_data.get('works', []):
                        if str(work.get('id')) == work_id:
                            work_type_id = str(work.get('workType', '0'))
                            mark_info['work_type'] = self._work_types_cache.get(work_type_id, 'Неизвестный тип')
                            self._log(f"Работа {work_id}: workType={work_type_id}, work_type={mark_info['work_type']}")
                            break
                    else:
                        self._log(f"Работа {work_id} не найдена в lesson_data['works'] для урока {lesson_id}")

                if work_id and work_id != '0' and self._student_cache:
                    try:
                        student_marks = await self._get_work_marks_by_id(int(work_id))
                        distribution = {}
                        for sm in student_marks:
                            mark_value = sm["mark"]
                            if mark_value not in distribution:
                                distribution[mark_value] = {"count": 0, "student_marks": []}
                            distribution[mark_value]["count"] += 1
                            distribution[mark_value]["student_marks"].append({
                                "name": sm["name"],
                                "mark": mark_value
                            })
                        mark_info['class_distribution'] = distribution
                        self._log(f"Распределение оценок для работы {work_id}: {len(student_marks)} записей")
                    except Exception as e:
                        self._log(f"Ошибка получения class_distribution для work_id={work_id}: {e}")

                result.append(mark_info)

            self._log(f"Fetched {len(result)} last marks, subject_id={subject_id}")
            return result

        except Exception as e:
            self._log(f"Unexpected error in get_last_marks: {e}")
            return result
        
    async def get_formatted_marks(self, start_date: datetime, end_date: Optional[datetime] = None) -> Dict[str, List[Dict[str, str]]]:
        """
        Асинхронно получает оценки за период, сгруппированные по предметам.

        **Назначение**:
        Этот метод извлекает все оценки за указанный период, форматируя их по предметам с подробной
        информацией о датах, типах работ, настроении оценок и темах уроков. Используется для анализа
        успеваемости ученика по каждому предмету.

        **Параметры**:
        - start_date (datetime): Начальная дата периода, с которой начинается поиск оценок.
        - end_date (datetime, optional): Конечная дата периода. Если None, используется та же дата,
          что и `start_date`, то есть метод вернет оценки только за один день.

        **Алгоритм работы**:
        1. Если `end_date` не указан, устанавливает его равным `start_date` для обработки одного дня.
        2. Выполняет запрос к API через эндпоинт `/persons/{person_id}/groups/{group_id}/schedules`
           для получения расписания за указанный период.
        3. Проверяет наличие данных в ответе. Если расписание пустое, возвращает пустой словарь.
        4. Обрабатывает данные расписания:
           - Извлекает допустимые ID предметов (`allowed_subject_ids`), типы работ (`work_types`),
             уроки (`lessons`) и оценки (`marks`) для текущего пользователя (`person_id`).
           - Обновляет кэш предметов `_subject_cache`, если в расписании встречаются новые предметы.
        5. Для каждой оценки:
           - Проверяет, относится ли она к допустимому предмету и находится ли в пределах периода.
           - Извлекает информацию об уроке (дата, тема) и оценке (дата, значение, тип работы, настроение).
           - Форматирует данные в словарь и добавляет в `formatted_marks`, группируя по названию предмета.
        6. Сортирует оценки внутри каждого предмета по дате выставления (`mark_date`).
        7. Логирует количество дней в расписании, пропущенные оценки (например, из-за некорректных
           данных или дат) и любые ошибки.
        8. Возвращает словарь, где ключи — названия предметов, а значения — списки оценок.

        **Возвращаемые значения**:
        - Dict[str, List[Dict[str, str]]]: Словарь, где:
          - Ключи: Названия предметов (например, "Математика").
          - Значения: Списки словарей с информацией об оценках, каждый содержащий:
            - `lesson_date`: Дата урока в формате DD.MM.YYYY.
            - `mark_date`: Дата выставления оценки в формате DD.MM.YYYY.
            - `value`: Значение оценки (например, "5").
            - `work_type`: Тип работы (например, "Контрольная").
            - `mood`: Настроение оценки (например, "Хорошо" или "Нет").
            - `lesson_title`: Тема урока.

        **Исключения**:
        - Exception: Ошибки API (например, неверный токен, недоступность сервера, таймаут).
          Обрабатываются внутри метода, возвращается пустой словарь.
        - ValueError: Если даты в данных урока или оценки имеют некорректный формат.
          Такие оценки пропускаются, и ошибка логируется.

        **Пример использования**:
        ```python
        marks = await formatter.get_formatted_marks(
            datetime(2025, 5, 1), datetime(2025, 5, 31)
        )
        for subject, marks_list in marks.items():
            print(f"{subject}:")
            for mark in marks_list:
                print(f"  {mark['mark_date']} - {mark['value']} ({mark['work_type']})")
        ```

        **Ошибки и их обработка**:
        - **Ошибка API**: Если запрос к API не удался (например, из-за неверного токена или сетевых проблем),
          метод возвращает пустой словарь. Решение: Проверить токен, соединение или повторить запрос.
        - **Пустое расписание**: Если за указанный период нет уроков, возвращается пустой словарь.
          Решение: Убедиться, что в Дневник.ру есть данные за этот период.
        - **Некорректный предмет**: Если оценка относится к предмету, отсутствующему в кэше или расписании,
          она пропускается. Решение: Обновить кэш предметов через `_load_subjects`.
        - **Некорректная дата**: Если дата урока или оценки не соответствует формату
          `%Y-%m-%dT%H:%M:%S` или `%Y-%m-%dT%H:%M:%S.%f`, оценка пропускается.
          Решение: Проверить структуру данных в API.
        - **Отсутствие данных об уроке**: Если для оценки не найден соответствующий урок,
          используются значения по умолчанию ("Неизвестно"). Решение: Проверить целостность данных в Дневник.ру.

        **Замечания**:
        - Группировка по предметам делает результат удобным для отображения в интерфейсах, таких как Telegram.
        - Метод зависит от расписания, что может ограничить получение оценок для старых периодов, если уроки не загружены.
        - Пропуск оценок из-за некорректных данных или дат логируется, что помогает диагностировать проблемы.
        - Сортировка по `mark_date` обеспечивает хронологический порядок оценок, что удобно для анализа.
        """
        if end_date is None:
            end_date = start_date
        try:
            async with dnevnik.AsyncDiaryAPI(token=self.token) as dn:
                schedule = await dn.get(
                    f"persons/{self.person_id}/groups/{self.group_id}/schedules",
                    params={
                        "startDate": start_date.strftime("%Y-%m-%dT00:00:00"),
                        "endDate": end_date.strftime("%Y-%m-%dT23:59:59")
                    }
                )
                self._log(f"Получено дней расписания: {len(schedule.get('days', []))}")
        except Exception as e:
            self._log(f"Ошибка при получении расписания: {str(e)}")
            return {}
        if not schedule.get('days'):
            self._log("Нет данных расписания за указанный период")
            return {}
        allowed_subject_ids = set()
        work_types = {}
        lessons = {}
        marks = []
        for day in schedule.get('days', []):
            day_date = datetime.strptime(day.get('date', '1970-01-01T00:00:00'), '%Y-%m-%dT%H:%M:%S').date()
            if start_date.date() <= day_date <= end_date.date():
                work_types.update({str(wt['id']): wt['name'] for wt in day.get('workTypes', [])})
                for lesson in day.get('lessons', []):
                    lessons[str(lesson['id'])] = lesson
                    subject_id = str(lesson.get('subjectId', '0'))
                    allowed_subject_ids.add(subject_id)
                    if subject_id not in self._subject_cache:
                        self._subject_cache[subject_id] = lesson.get('subjectName', 'Неизвестный предмет')
                        self._log(f"Добавлен предмет в _subject_cache: {subject_id} -> {self._subject_cache[subject_id]}")
                for mark in day.get('marks', []):
                    if str(mark['person']) == self.person_id:
                        marks.append(mark)
        formatted_marks = defaultdict(list)
        for mark in marks:
            lesson_id = str(mark.get('lesson_str', '0'))
            lesson_data = lessons.get(lesson_id, {})
            subject_id = str(lesson_data.get('subjectId', '0')) if lesson_data.get('subjectId') else None
            if not subject_id or subject_id not in allowed_subject_ids or subject_id not in self._subject_cache:
                self._log(f"Пропущена оценка для урока {lesson_id}: subject_id={subject_id} отсутствует")
                continue
            subject_name = self._subject_cache.get(subject_id, 'Неизвестный предмет')
            lesson_date_str = lesson_data.get('date', day.get('date', '1970-01-01T00:00:00'))
            try:
                lesson_date = datetime.strptime(lesson_date_str, '%Y-%m-%dT%H:%M:%S').date()
            except ValueError:
                self._log(f"Некорректная дата урока {lesson_id}: {lesson_date_str}")
                continue
            if lesson_date < start_date.date() or lesson_date > end_date.date():
                self._log(f"Пропущена оценка для урока {lesson_id}: дата {lesson_date} вне диапазона")
                continue
            mark_date = datetime.strptime(mark.get('date', '1970-01-01T00:00:00.000000'), '%Y-%m-%dT%H:%M:%S.%f').date()
            work_type_id = str(mark.get('workType', '0'))
            formatted_marks[subject_name].append({
                'lesson_date': lesson_date.strftime('%d.%m.%Y'),
                'mark_date': mark_date.strftime('%d.%m.%Y'),
                'value': str(mark.get('value', 'Нет оценки')),
                'work_type': work_types.get(work_type_id, 'Неизвестно'),
                'mood': mark.get('mood', 'Нет'),
                'lesson_title': lesson_data.get('title', 'Неизвестно')
            })
        for subject in formatted_marks:
            formatted_marks[subject] = sorted(formatted_marks[subject], key=lambda x: x['mark_date'])
        return dict(formatted_marks)

    async def get_group_teachers(self, start_date: Optional[datetime] = None, end_date: Optional[datetime] = None) -> List[Dict[str, str]]:
        """
        Асинхронно получает список учителей группы за указанный период.

        **Назначение**:
        Этот метод извлекает информацию об учителях, которые ведут уроки в группе, на основе данных
        о домашних заданиях за указанный период. Используется для предоставления списка преподавателей
        с их именами, предметами и контактами.

        **Параметры**:
        - start_date (datetime, optional): Начальная дата периода. Если None, используется
          текущая дата минус 7 дней.
        - end_date (datetime, optional): Конечная дата периода. Если None, используется
          текущая дата плюс 30 дней.

        **Алгоритм работы**:
        1. Если `start_date` или `end_date` не указаны, устанавливает значения по умолчанию:
           - `start_date`: 7 дней назад.
           - `end_date`: через 30 дней.
        2. Проверяет, что `end_date` не раньше `start_date`. Если это так, выбрасывает исключение.
        3. Выполняет запрос к API через эндпоинт `/persons/{person_id}/school/{school_id}/homeworks`
           для получения уроков с домашними заданиями за период.
        4. Извлекает ID учителей из уроков, фильтруя по датам периода.
        5. Для каждого уникального ID учителя:
           - Получает информацию из кэша `_teacher_cache` или использует значения по умолчанию.
           - Формирует словарь с данными: ID, полное имя, краткое имя, предметы, email, должность.
        6. Сортирует список учителей по ID для предсказуемого порядка.
        7. Логирует ошибки, если запрос не удался, и возвращает пустой список.
        8. Возвращает список словарей с информацией об учителях.

        **Возвращаемые значения**:
        - List[Dict[str, str]]: Список словарей, каждый из которых содержит:
          - `id`: ID учителя.
          - `fullName`: Полное имя (например, "Иванов Иван Иванович").
          - `shortName`: Краткое имя (например, "Иванов И.И.").
          - `subjects`: Список предметов, которые ведет учитель.
          - `email`: Электронная почта учителя.
          - `position`: Должность (например, "Учитель математики").

        **Исключения**:
        - ValueError: Если `end_date` раньше `start_date`.
        - Exception: Ошибки API (например, неверный токен, недоступность сервера).
          Обрабатываются внутри метода, возвращается пустой список.

        **Пример использования**:
        ```python
        teachers = await formatter.get_group_teachers()
        for teacher in teachers:
            print(f"{teacher['fullName']} ({teacher['subjects']}): {teacher['email']}")
        ```

        **Ошибки и их обработка**:
        - **Некорректные даты**: Если `end_date` раньше `start_date`, выбрасывается `ValueError`.
          Решение: Убедиться, что даты указаны правильно.
        - **Ошибка API**: Если запрос к API не удался, возвращается пустой список.
          Решение: Проверить токен, соединение или повторить запрос.
        - **Пустой ответ API**: Если за период нет уроков или домашних заданий,
          возвращается пустой список. Решение: Убедиться, что в Дневник.ру есть данные.
        - **Отсутствие учителя в кэше**: Используются значения по умолчанию ("Неизвестно").
          Решение: Обновить кэш через `_load_teachers`.

        **Замечания**:
        - Метод использует данные о домашних заданиях, что может ограничить список учителей
          только теми, кто задавал задания.
        - Значения по умолчанию для отсутствующих учителей предотвращают сбои, но могут быть
          менее информативными.
        - Сортировка по ID обеспечивает стабильный порядок вывода.
        """
        if start_date is None:
            start_date = datetime.now() - timedelta(days=7)
        if end_date is None:
            end_date = datetime.now() + timedelta(days=30)
        if end_date < start_date:
            raise ValueError("end_date не может быть раньше start_date")
        try:
            async with dnevnik.AsyncDiaryAPI(token=self.token) as dn:
                homeworks = await dn.get(
                    f"persons/{self.person_id}/school/{self.school_id}/homeworks",
                    params={
                        "startDate": start_date.strftime('%Y-%m-%d'),
                        "endDate": end_date.strftime('%Y-%m-%d')
                    }
                )
                lessons = homeworks.get('lessons', [])
        except Exception as e:
            self._log(f"Ошибка при получении уроков: {str(e)}")
            return []
        teacher_ids = set()
        for lesson in lessons:
            lesson_date = datetime.strptime(lesson.get('date', '1970-01-01'), '%Y-%m-%dT%H:%M:%S').date()
            if start_date.date() <= lesson_date <= end_date.date():
                for teacher_id in lesson.get('teachers', []):
                    teacher_ids.add(str(teacher_id))
        result = []
        for teacher_id in sorted(teacher_ids):
            teacher_info = self._teacher_cache.get(teacher_id, {
                'shortName': 'Неизвестно',
                'fullName': 'Неизвестно',
                'subjects': 'Неизвестно',
                'email': '',
                'position': 'Неизвестно'
            })
            result.append({
                'id': teacher_id,
                'fullName': teacher_info['fullName'],
                'shortName': teacher_info['shortName'],
                'subjects': teacher_info['subjects'],
                'email': teacher_info['email'],
                'position': teacher_info['position']
            })
        return result

    async def _get_quarter_period_id(self, quarter: int, study_year: Optional[int] = None) -> Optional[Tuple[str, datetime, datetime]]:
        """
        Асинхронно получает ID периода и даты для указанной четверти.

        **Назначение**:
        Этот вспомогательный метод определяет идентификатор учебного периода (четверть или семестр)
        и его временные границы (начало и конец) для использования в методах, таких как
        `get_formatted_final_marks` или `get_class_ranking`. Поддерживает выбор текущего или
        ближайшего периода.

        **Параметры**:
        - quarter (int): Номер четверти (1–4). Должен быть в указанном диапазоне.
        - study_year (int, optional): Учебный год. Если None, выбирается текущий или ближайший период.

        **Алгоритм работы**:
        1. Проверяет, что `quarter` находится в диапазоне 1–4. Если нет, логирует ошибку и возвращает None.
        2. Выполняет запрос к API через эндпоинт `/edu-groups/{group_id}/reporting-periods`
           для получения списка учебных периодов.
        3. Определяет ожидаемый номер периода для четверти или семестра:
           - Для четверти: `quarter - 1` (нумерация начинается с 0).
           - Для семестра: 0 для 1–2 четвертей, 1 для 3–4 четвертей.
        4. Итерируется по периодам, проверяя:
           - Тип периода (`Quarter` или `Semester`).
           - Номер периода (соответствие ожидаемому).
           - Даты начала и конца (форматирование и валидность).
           - Год периода (соответствие `study_year`, если указан).
        5. Выбирает период, который:
           - Включает текущую дату (приоритет).
           - Или является ближайшим по дате начала к текущей дате.
        6. Форматирует даты в объекты `datetime` и возвращает кортеж: ID периода, дата начала, дата конца.
        7. Логирует подробную информацию о проверяемых периодах, выбранном периоде и любых ошибках.
        8. Если период не найден, возвращает None.

        **Возвращаемые значения**:
        - Optional[Tuple[str, datetime, datetime]]: Кортеж, содержащий:
          - ID периода (строка).
          - Дата начала периода (datetime).
          - Дата конца периода (datetime).
          Или None, если период не найден.

        **Исключения**:
        - Exception: Ошибки API (например, неверный токен, недоступность сервера).
          Обрабатываются внутри метода, возвращается None.
        - ValueError: Если даты периода имеют некорректный формат.
          Период пропускается, и проверка продолжается.

        **Пример использования**:
        ```python
        period = await formatter._get_quarter_period_id(quarter=3, study_year=2025)
        if period:
            period_id, start_date, end_date = period
            print(f"Период: {period_id}, с {start_date} по {end_date}")
        ```

        **Ошибки и их обработка**:
        - **Некорректная четверть**: Если `quarter` не в диапазоне 1–4, возвращается None.
          Решение: Указать правильный номер четверти.
        - **Ошибка API**: Если запрос к API не удался, возвращается None.
          Решение: Проверить токен, соединение или повторить запрос.
        - **Некорректные даты**: Если даты периода не соответствуют формату
          `%Y-%m-%dT%H:%M:%S` или `%Y-%m-%dT%H:%M:%S.%f`, период пропускается.
          Решение: Проверить данные в API.
        - **Отсутствие подходящего периода**: Если ни один период не соответствует критериям,
          возвращается None. Решение: Убедиться, что в Дневник.ру настроены периоды для группы.

        **Замечания**:
        - Метод поддерживает как четверти, так и семестры, что делает его гибким для разных систем.
        - Приоритет отдается текущему периоду, что удобно для актуальных данных.
        - Логирование всех проверяемых периодов помогает диагностировать, почему период не выбран.
        - Выбор ближайшего периода по дате начала может быть полезен для исторических данных.
        """
        if quarter not in [1, 2, 3, 4]:
            self._log(f"Некорректный номер четверти: {quarter}")
            return None

        try:
            async with dnevnik.AsyncDiaryAPI(token=self.token) as dn:
                periods = await dn.get(f"edu-groups/{self.group_id}/reporting-periods")
                self._log(f"Сырой ответ reporting-periods:\n{json.dumps(periods, ensure_ascii=False, indent=2)}")
        except Exception as e:
            self._log(f"Ошибка при получении периодов: {str(e)}")
            return None

        quarter_to_number = {
            'Quarter': quarter - 1,
            'Semester': 0 if quarter in [1, 2] else 1
        }

        current_date = datetime.now()
        candidate_periods = []
        min_date_diff = None
        closest_period = None

        for period in periods:
            period_type = period.get('type', '')
            period_number = period.get('number', -1)
            start_date_str = period.get('start', '')
            finish_date_str = period.get('finish', '')
            period_year = period.get('year', 0)
            period_name = period.get('name', 'Неизвестный период')

            self._log(f"Проверяю период: type={period_type}, number={period_number}, name={period_name}, start={start_date_str}, finish={finish_date_str}, year={period_year}")

            if period_type not in ['Quarter', 'Semester']:
                self._log(f"Пропущен период: неподдерживаемый тип {period_type}")
                continue

            expected_number = quarter_to_number.get(period_type)
            if period_number != expected_number:
                self._log(f"Пропущен период: number={period_number} не соответствует ожидаемому {expected_number} для {period_type}")
                continue

            try:
                start_date = datetime.strptime(start_date_str, '%Y-%m-%dT%H:%M:%S')
                finish_date = datetime.strptime(finish_date_str, '%Y-%m-%dT%H:%M:%S')
            except ValueError:
                try:
                    start_date = datetime.strptime(start_date_str, '%Y-%m-%dT%H:%M:%S.%f')
                    finish_date = datetime.strptime(finish_date_str, '%Y-%m-%dT%H:%M:%S.%f')
                except ValueError:
                    self._log(f"Некорректный формат дат: start={start_date_str}, finish={finish_date_str}")
                    continue

            effective_year = start_date.year if start_date.month >= 9 else finish_date.year

            if study_year is not None and effective_year != study_year and effective_year != study_year - 1:
                self._log(f"Пропущен период: год {effective_year} не соответствует запрошенному {study_year}")
                continue

            period_data = (str(period.get('id')), start_date, finish_date, period_name)

            if start_date <= current_date <= finish_date:
                self._log(f"Выбран период, включающий текущую дату: ID={period_data[0]}, name={period_name}")
                return period_data[:3]

            candidate_periods.append(period_data)
            date_diff = abs((start_date - current_date).total_seconds())
            if min_date_diff is None or date_diff < min_date_diff:
                min_date_diff = date_diff
                closest_period = period_data

        if closest_period:
            self._log(f"Выбран ближайший период: ID={closest_period[0]}, name={closest_period[3]}")
            return closest_period[:3]

        self._log(f"Период для четверти {quarter} не найден")
        return None

    async def get_formatted_final_marks(self, quarter: int, study_year: Optional[int] = None) -> List[Dict[str, any]]:
        """
        Асинхронно получает итоговые оценки за четверть по всем предметам.

        **Назначение**:
        Этот метод извлекает итоговые оценки за указанную четверть, включая средний балл
        по каждому предмету, основываясь на данных расписания и оценок. Используется для
        подведения итогов успеваемости за учебный период.

        **Параметры**:
        - quarter (int): Номер четверти (1–4). Должен быть в указанном диапазоне.
        - study_year (int, optional): Учебный год. Если None, выбирается текущий или ближайший период.

        **Алгоритм работы**:
        1. Проверяет, что `quarter` находится в диапазоне 1–4. Если нет, выбрасывает исключение.
        2. Вызывает `_get_quarter_period_id` для получения ID периода и его дат (начало и конец).
        3. Если период не найден, возвращает пустой список.
        4. Запрашивает расписание за период через `/persons/{person_id}/groups/{group_id}/schedules`.
        5. Извлекает активные предметы (`active_subject_ids`) из расписания.
        6. Если расписание пустое, использует все предметы из `_subject_cache` как запасной вариант.
        7. Для каждого предмета:
           - Запрашивает оценки через `get_person_subject_marks` за период.
           - Фильтрует числовые оценки (игнорируя текстовые, например, "зачет").
           - Вычисляет средний балл с округлением до 1 знака после запятой.
           - Если оценок нет, устанавливает значение "Нет оценок".
        8. Формирует список словарей с данными: название предмета, список оценок, средний балл.
        9. Сортирует результат по названию предмета.
        10. Логирует количество дней в расписании, пропущенные предметы и любые ошибки.
        11. Возвращает отформатированный список итоговых оценок.

        **Возвращаемые значения**:
        - List[Dict[str, any]]: Список словарей, каждый из которых содержит:
          - `название предмета`: Название предмета (например, "Математика").
          - `оценки`: Список оценок (например, ["5", "4", "5"]).
          - `средний балл`: Средний балл (например, "4.7") или "Нет оценок".

        **Исключения**:
        - ValueError: Если `quarter` не в диапазоне 1–4.
        - Exception: Ошибки API (например, неверный токен, недоступность сервера).
          Обрабатываются внутри метода, для проблемных предметов оценки не включаются.
        - statistics.StatisticsError: Если не удается вычислить средний балл (например, пустой список).
          Устанавливается значение "Нет данных".

        **Пример использования**:
        ```python
        final_marks = await formatter.get_formatted_final_marks(quarter=3, study_year=2025)
        for mark in final_marks:
            print(f"{mark['название предмета']}: {mark['средний балл']} ({mark['оценки']})")
        ```

        **Ошибки и их обработка**:
        - **Некорректная четверть**: Выбрасывается `ValueError`. Решение: Указать правильный номер четверти.
        - **Отсутствие периода**: Если `_get_quarter_period_id` возвращает None, возвращается пустой список.
          Решение: Проверить настройки периодов в Дневник.ру.
        - **Ошибка API**: Если запрос расписания или оценок не удался, используются пустые данные.
          Решение: Проверить токен, соединение или повторить запрос.
        - **Пустое расписание**: Используются все предметы из кэша, что может включать неактивные предметы.
          Решение: Убедиться, что расписание заполнено в Дневник.ру.
        - **Некорректные оценки**: Текстовые оценки игнорируются, числовые обрабатываются.
          Решение: Проверить данные оценок в API.

        **Замечания**:
        - Средний балл вычисляется только для числовых оценок, что исключает текстовые отметки.
        - Использование `_subject_cache` как запасного варианта предотвращает сбои, но может быть менее точным.
        - Сортировка по названию предмета упрощает чтение результата.
        """
        if quarter not in [1, 2, 3, 4]:
            raise ValueError("Номер четверти должен быть от 1 до 4")
        period_data = await self._get_quarter_period_id(quarter=quarter, study_year=study_year)
        if not period_data:
            return []
        period_id, start_date, finish_date = period_data
        try:
            async with dnevnik.AsyncDiaryAPI(token=self.token) as dn:
                schedule = await dn.get(
                    f"persons/{self.person_id}/groups/{self.group_id}/schedules",
                    params={
                        "startDate": start_date.strftime("%Y-%m-%dT00:00:00"),
                        "endDate": finish_date.strftime("%Y-%m-%dT23:59:59")
                    }
                )
                self._log(f"Получено дней расписания: {len(schedule.get('days', []))}")
        except Exception as e:
            self._log(f"Ошибка при получении расписания: {str(e)}")
            schedule = {'days': []}
        active_subject_ids = set()
        for day in schedule.get('days', []):
            day_date = datetime.strptime(day.get('date', '1970-01-01T00:00:00'), '%Y-%m-%dT%H:%M:%S').date()
            if start_date.date() <= day_date <= finish_date.date():
                for lesson in day.get('lessons', []):
                    subject_id = str(lesson.get('subjectId', '0'))
                    active_subject_ids.add(subject_id)
                    for subject in day.get('subjects', []):
                        subj_id = str(subject.get('id'))
                        subj_name = subject.get('name', 'Неизвестный предмет').strip()
                        if subj_id and subj_name and subj_id not in self._subject_cache:
                            self._subject_cache[subj_id] = subj_name
                            self._log(f"Добавлен предмет в _subject_cache: {subj_id} -> {subj_name}")
        if not active_subject_ids:
            self._log("Расписание пустое, использую все предметы из _subject_cache")
            active_subject_ids = set(self._subject_cache.keys())
        formatted_marks = []
        for subject_id in active_subject_ids:
            if subject_id not in self._subject_cache:
                self._log(f"Пропущен предмет {subject_id}: отсутствует в _subject_cache")
                continue
            try:
                async with dnevnik.AsyncDiaryAPI(token=self.token) as dn:
                    marks = await dn.get_person_subject_marks(self.person_id, int(subject_id), start_date, finish_date)
            except Exception as e:
                self._log(f"Ошибка при получении оценок для предмета {subject_id}: {str(e)}")
                marks = []
            grades = [mark['value'] for mark in marks if mark.get('value', '').replace('.', '', 1).isdigit()]
            if grades:
                try:
                    average = statistics.mean([float(g) for g in grades])
                    average_str = str(round(average, 1))
                except statistics.StatisticsError:
                    average_str = "Нет данных"
            else:
                average_str = "Нет оценок"
            formatted_marks.append({
                'название предмета': self._subject_cache.get(subject_id, 'Неизвестный предмет'),
                'оценки': grades,
                'средний балл': average_str
            })
        return sorted(formatted_marks, key=lambda x: x['название предмета'])

    async def get_class_ranking(self, quarter: int, study_year: Optional[int] = None) -> List[Dict]:
        """
        Асинхронно формирует рейтинг класса на основе средних оценок за четверть.

        **Назначение**:
        Этот метод вычисляет средний балл каждого ученика в классе по всем предметам за указанную
        четверть и сортирует их по убыванию среднего балла. Используется для анализа успеваемости
        всего класса.

        **Параметры**:
        - quarter (int): Номер четверти (1–4). Должен быть в указанном диапазоне.
        - study_year (int, optional): Учебный год. Если None, выбирается текущий или ближайший период.

        **Алгоритм работы**:
        1. Проверяет, что `quarter` находится в диапазоне 1–4. Если нет, выбрасывает исключение.
        2. Вызывает `_get_quarter_period_id` для получения ID периода и его дат.
        3. Если период не найден, возвращает пустой список.
        4. Для каждого ученика в `_student_cache`:
           - Собирает все числовые оценки по всем предметам за период через `get_person_subject_marks`.
           - Вычисляет средний балл по всем оценкам.
           - Если оценок нет, средний балл устанавливается в 0.
        5. Формирует список словарей с данными: имя ученика, средний балл, количество оценок.
        6. Сортирует список по среднему баллу в порядке убывания.
        7. Логирует ошибки для каждого ученика и предмета, если запросы не удаются.
        8. Возвращает отсортированный рейтинг.

        **Возвращаемые значения**:
        - List[Dict]: Список словарей, каждый из которых содержит:
          - `name`: Имя ученика.
          - `avg_grade`: Средний балл, округленный до 2 знаков после запятой.
          - `marks_count`: Количество оценок.

        **Исключения**:
        - ValueError: Если `quarter` не в диапазоне 1–4.
        - Exception: Ошибки API (например, неверный токен, недоступность сервера).
          Обрабатываются внутри метода, для проблемных учеников оценки игнорируются.
        - statistics.StatisticsError: Если не удается вычислить средний балл (пустой список оценок).
          Средний балл устанавливается в 0.

        **Пример использования**:
        ```python
        ranking = await formatter.get_class_ranking(quarter=3, study_year=2025)
        for student in ranking:
            print(f"{student['name']}: {student['avg_grade']} ({student['marks_count']} оценок)")
        ```

        **Ошибки и их обработка**:
        - **Некорректная четверть**: Выбрасывается `ValueError`. Решение: Указать правильный номер четверти.
        - **Отсутствие периода**: Если `_get_quarter_period_id` возвращает None, возвращается пустой список.
          Решение: Проверить настройки периодов в Дневник.ру.
        - **Ошибка API**: Если запрос оценок для ученика или предмета не удался, оценки игнорируются.
          Решение: Проверить токен, соединение или повторить запрос.
        - **Пустой кэш учеников**: Если `_student_cache` пуст, возвращается пустой список.
          Решение: Обновить кэш через `_load_students`.
        - **Некорректные оценки**: Текстовые оценки игнорируются, числовые обрабатываются.
          Решение: Проверить данные оценок в API.

        **Замечания**:
        - Средний балл 0 для учеников без оценок позволяет включить их в рейтинг, но в конец списка.
        - Сортировка по убыванию среднего балла выделяет лучших учеников в начале.
        - Логирование ошибок для каждого ученика и предмета помогает диагностировать проблемы.
        - Метод может быть ресурсоемким из-за множества запросов к API для каждого ученика и предмета.
        """
        if quarter not in [1, 2, 3, 4]:
            raise ValueError("Номер четверти должен быть от 1 до 4")
        period_data = await self._get_quarter_period_id(quarter=quarter, study_year=study_year)
        if not period_data:
            return []
        period_id, start_date, finish_date = period_data
        ranking = []
        for student_id, student_name in self._student_cache.items():
            student_grades = []
            for subject_id in self._subject_cache:
                try:
                    async with dnevnik.AsyncDiaryAPI(token=self.token) as dn:
                        marks = await dn.get_person_subject_marks(student_id, int(subject_id), start_date, finish_date)
                        grades = [float(mark['value']) for mark in marks if mark.get('value', '').replace('.', '', 1).isdigit()]
                        student_grades.extend(grades)
                except Exception as e:
                    self._log(f"Ошибка при получении оценок для ученика {student_id}, предмет {subject_id}: {str(e)}")
            avg_grade = statistics.mean(student_grades) if student_grades else 0
            ranking.append({
                'name': student_name,
                'avg_grade': round(avg_grade, 2),
                'marks_count': len(student_grades)
            })
        ranking.sort(key=lambda x: x['avg_grade'], reverse=True)
        return ranking

    async def get_subject_stats(self, quarter: int, subject_id: int, study_year: Optional[int] = None) -> Dict[str, int]:
        """
        Асинхронно получает гистограмму оценок по предмету за четверть.

        **Назначение**:
        Этот метод возвращает распределение оценок (например, сколько учеников получили "5", "4" и т.д.)
        по указанному предмету за четверть. Используется для анализа успеваемости класса по конкретному предмету.

        **Параметры**:
        - quarter (int): Номер четверти (1–4). Должен быть в указанном диапазоне.
        - subject_id (int): ID предмета, для которого запрашивается статистика.
        - study_year (int, optional): Учебный год. Если None, выбирается текущий или ближайший период.

        **Алгоритм работы**:
        1. Проверяет, что `quarter` находится в диапазоне 1–4. Если нет, выбрасывает исключение.
        2. Вызывает `_get_quarter_period_id` для получения ID периода и его дат.
        3. Если период не найден, возвращает пустой словарь.
        4. Выполняет запрос к API через `get_subject_marks_histogram` для получения гистограммы оценок
           по предмету за период.
        5. Обрабатывает ответ, суммируя количество каждой оценки (например, "5": 10, "4": 15).
        6. Логирует ошибки, если запрос не удался, и возвращает пустой словарь.
        7. Возвращает словарь с распределением оценок.

        **Возвращаемые значения**:
        - Dict[str, int]: Словарь, где:
          - Ключи: Значения оценок (например, "5", "4").
          - Значения: Количество учеников, получивших эту оценку.

        **Исключения**:
        - ValueError: Если `quarter` не в диапазоне 1–4.
        - Exception: Ошибки API (например, неверный токен, недоступность сервера).
          Обрабатываются внутри метода, возвращается пустой словарь.

        **Пример использования**:
        ```python
        stats = await formatter.get_subject_stats(quarter=3, subject_id=123, study_year=2025)
        print(f"Распределение оценок: {stats}")
        ```

        **Ошибки и их обработка**:
        - **Некорректная четверть**: Выбрасывается `ValueError`. Решение: Указать правильный номер четверти.
        - **Отсутствие периода**: Если `_get_quarter_period_id` возвращает None, возвращается пустой словарь.
          Решение: Проверить настройки периодов в Дневник.ру.
        - **Ошибка API**: Если запрос гистограммы не удался, возвращается пустой словарь.
          Решение: Проверить токен, соединение или повторить запрос.
        - **Некорректный subject_id**: Если предмет не существует, API может вернуть пустой ответ.
          Решение: Проверить ID предмета в `_subject_cache`.

        **Замечания**:
        - Гистограмма полезна для визуализации успеваемости класса, например, в графиках.
        - Метод зависит от API, предоставляющего статистику, что может быть ограничено в некоторых школах.
        - Пустой словарь в случае ошибки позволяет продолжить работу без сбоев.
        """
        if quarter not in [1, 2, 3, 4]:
            raise ValueError("Номер четверти должен быть от 1 до 4")
        period_data = await self._get_quarter_period_id(quarter=quarter, study_year=study_year)
        if not period_data:
            return {}
        period_id, start_date, finish_date = period_data
        try:
            async with dnevnik.AsyncDiaryAPI(token=self.token) as dn:
                histogram = await dn.get_subject_marks_histogram(self.group_id, period_id, subject_id)
                hist_data = defaultdict(int)
                for work in histogram.get('works', []):
                    for mark_number in work.get('markNumbers', []):
                        for mark in mark_number.get('marks', []):
                            value = str(mark.get('value'))
                            count = mark.get('count', 0)
                            hist_data[value] += count
                return dict(hist_data)
        except Exception as e:
            self._log(f"Ошибка при получении статистики по предмету {subject_id}: {str(e)}")
            return {}

    async def get_subject_ranking(self, quarter: int, subject_id: int, study_year: Optional[int] = None) -> List[Dict]:
        """
        Асинхронно формирует рейтинг учеников по предмету за четверть.

        **Назначение**:
        Этот метод вычисляет средний балл каждого ученика по указанному предмету за четверть
        и сортирует их по убыванию среднего балла. Используется для анализа успеваемости по конкретному предмету.

        **Параметры**:
        - quarter (int): Номер четверти (1–4). Должен быть в указанном диапазоне.
        - subject_id (int): ID предмета, для которого формируется рейтинг.
        - study_year (int, optional): Учебный год. Если None, выбирается текущий или ближайший период.

        **Алгоритм работы**:
        1. Проверяет, что `quarter` находится в диапазоне 1–4. Если нет, выбрасывает исключение.
        2. Вызывает `_get_quarter_period_id` для получения ID периода и его дат.
        3. Если период не найден, возвращает пустой список.
        4. Проверяет, существует ли `subject_id` в `_subject_cache`. Если нет, возвращает пустой список.
        5. Если `_student_cache` пуст, пытается загрузить учеников через запрос к `/edu-groups/{group_id}`.
        6. Для каждого ученика:
           - Запрашивает оценки по предмету через `get_person_subject_marks`.
           - Фильтрует числовые оценки и вычисляет средний балл.
           - Если оценок нет, средний балл устанавливается в 0.
        7. Формирует список словарей с данными: имя ученика, средний балл, количество оценок.
        8. Сортирует список по среднему баллу в порядке убывания.
        9. Логирует ошибки для каждого ученика и возвращает рейтинг.

        **Возвращаемые значения**:
        - List[Dict]: Список словарей, каждый из которых содержит:
          - `name`: Имя ученика.
          - `avg_grade`: Средний балл, округленный до 2 знаков после запятой.
          - `marks_count`: Количество оценок.

        **Исключения**:
        - ValueError: Если `quarter` не в диапазоне 1–4.
        - Exception: Ошибки API (например, неверный токен, недоступность сервера).
          Обрабатываются внутри метода, для проблемных учеников оценки игнорируются.

        **Пример использования**:
        ```python
        ranking = await formatter.get_subject_ranking(quarter=3, subject_id=123, study_year=2025)
        for student in ranking:
            print(f"{student['name']}: {student['avg_grade']} ({student['marks_count']} оценок)")
        ```

        **Ошибки и их обработка**:
        - **Некорректная четверть**: Выбрасывается `ValueError`. Решение: Указать правильный номер четверти.
        - **Отсутствие периода**: Если `_get_quarter_period_id` возвращает None, возвращается пустой список.
          Решение: Проверить настройки периодов в Дневник.ру.
        - **Некорректный subject_id**: Если предмет не найден в `_subject_cache`, возвращается пустой список.
          Решение: Проверить ID предмета или обновить кэш.
        - **Пустой кэш учеников**: Пытается загрузить учеников, если не удается — возвращает пустой список.
          Решение: Убедиться, что группа настроена в Дневник.ру.
        - **Ошибка API**: Если запрос оценок не удался, оценки игнорируются.
          Решение: Проверить токен, соединение или повторить запрос.

        **Замечания**:
        - Метод похож на `get_class_ranking`, но ограничен одним предметом, что снижает количество запросов.
        - Загрузка учеников при пустом кэше делает метод более устойчивым.
        - Средний балл 0 для учеников без оценок позволяет включить их в рейтинг.
        """
        if quarter not in [1, 2, 3, 4]:
            raise ValueError("Номер четверти должен быть от 1 до 4")
        period_data = await self._get_quarter_period_id(quarter=quarter, study_year=study_year)
        if not period_data:
            return []
        period_id, start_date, finish_date = period_data
        if str(subject_id) not in self._subject_cache:
            self._log(f"Предмет {subject_id} отсутствует в _subject_cache")
            return []
        if not self._student_cache:
            self._log("Кэш учеников пуст, загружаю данные")
            try:
                async with dnevnik.AsyncDiaryAPI(token=self.token) as dn:
                    group = await dn.get(f"edu-groups/{self.group_id}")
                    for student in group.get('students', []):
                        student_id = str(student.get('id'))
                        student_name = student.get('shortName', 'Неизвестный ученик')
                        self._student_cache[student_id] = student_name
                    self._log(f"Загружено учеников: {len(self._student_cache)}")
            except Exception as e:
                self._log(f"Ошибка при загрузке учеников: {str(e)}")
                return []
        ranking = []
        for student_id, student_name in self._student_cache.items():
            try:
                async with dnevnik.AsyncDiaryAPI(token=self.token) as dn:
                    marks = await dn.get_person_subject_marks(student_id, subject_id, start_date, finish_date)
                    grades = [float(mark['value']) for mark in marks if mark.get('value', '').replace('.', '', 1).isdigit()]
                    avg_grade = statistics.mean(grades) if grades else 0
                    ranking.append({
                        'name': student_name,
                        'avg_grade': round(avg_grade, 2),
                        'marks_count': len(grades)
                    })
            except Exception as e:
                self._log(f"Ошибка при получении оценок для ученика {student_id}, предмет {subject_id}: {str(e)}")
        ranking.sort(key=lambda x: x['avg_grade'], reverse=True)
        return ranking

    async def get_upcoming_tests(self) -> List[Dict[str, str]]:
        """
        Асинхронно получает список предстоящих тестов на ближайшие две недели с весом >= 5.

        **Назначение**:
        Этот метод извлекает информацию о контрольных работах, тестах и других значимых заданиях
        (с весом 5 и выше) из расписания на ближайшие 14 дней. Используется для уведомления
        учеников о важных проверочных мероприятиях.

        **Алгоритм работы**:
        1. Устанавливает период: текущая дата и следующие 14 дней.
        2. Логирует начало загрузки расписания за указанный период.
        3. Вызывает `get_formatted_schedule` для получения расписания.
        4. Итерируется по дням и урокам в расписании, проверяя работы (`works`).
        5. Для каждой работы:
           - Проверяет, есть ли тип работы в словаре `title_to_weight`.
           - Если вес работы >= 5, формирует словарь с данными: дата, предмет, тип работы, описание, вес.
        6. Сортирует тесты по дате для хронологического порядка.
        7. Логирует количество найденных тестов или сообщение, если тесты не найдены.
        8. Возвращает список тестов.

        **Возвращаемые значения**:
        - List[Dict[str, str]]: Список словарей, каждый из которых содержит:
          - `date`: Дата теста в формате YYYY-MM-DD.
          - `subject`: Название предмета.
          - `work_type`: Тип работы (например, "Контрольная").
          - `description`: Описание (например, "Контрольная: Тема урока").
          - `weight`: Вес работы (например, 9).

        **Исключения**:
        - Exception: Ошибки API обрабатываются в `get_formatted_schedule`, поэтому метод
          возвращает пустой список в случае проблем.

        **Пример использования**:
        ```python
        tests = await formatter.get_upcoming_tests()
        for test in tests:
            print(f"{test['date']} - {test['subject']}: {test['work_type']} (вес {test['weight']})")
        ```

        **Ошибки и их обработка**:
        - **Ошибка API**: Обрабатывается в `get_formatted_schedule`, возвращается пустое расписание,
          что приводит к пустому списку тестов. Решение: Проверить токен, соединение или повторить запрос.
        - **Пустое расписание**: Если за 14 дней нет уроков, возвращается пустой список.
          Решение: Убедиться, что расписание заполнено в Дневник.ру.
        - **Отсутствие тестов**: Если нет работ с весом >= 5, возвращается пустой список.
          Решение: Проверить настройки типов работ в Дневник.ру или словарь `title_to_weight`.

        **Замечания**:
        - Вес 5 и выше выбран как порог для значимых работ (например, контрольные, диктанты).
        - Словарь `title_to_weight` определяет, какие работы считаются тестами, и может быть расширен.
        - Сортировка по дате упрощает планирование подготовки к тестам.
        """
        start_date = datetime.now()
        end_date = start_date + timedelta(days=14)

        self._log(f"Fetching schedule from {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}")

        schedule = await self.get_formatted_schedule(start_date, end_date)

        tests = []
        for date_str, lessons in schedule.items():
            for lesson in lessons:
                for work in lesson.get("works", []):
                    work_type = work["work"]
                    if work_type in self.title_to_weight:
                        weight = self.title_to_weight[work_type]
                        test_info = {
                            "date": date_str,
                            "subject": lesson["subject"],
                            "work_type": work_type,
                            "description": f"{work_type}: {lesson['title']}",
                            "weight": weight
                        }
                        tests.append(test_info)

        tests.sort(key=lambda x: datetime.strptime(x["date"], "%Y-%m-%d"))

        self._log(f"Найдено предстоящих тестов: {len(tests)}")
        if not tests:
            self._log("No upcoming tests found in the schedule.")

        return tests

    async def analyze_data(self, analysis_type: str, start_date: Optional[datetime] = None, end_date: Optional[datetime] = None, quarter: Optional[int] = None, study_year: Optional[int] = None) -> str:
        """
        Асинхронно выполняет AI-анализ данных на основе указанного типа.

        **Назначение**:
        Этот метод отправляет данные (расписание, оценки, рейтинг) в AI (DeepSeek) для получения
        человекочитаемого анализа или рекомендаций. Использует шаблоны промптов из `prompts.json`.

        **Параметры**:
        - analysis_type (str): Тип анализа: 'weeks' (расписание), 'marks' (оценки), 'ranking' (рейтинг).
        - start_date (datetime, optional): Начальная дата для 'weeks' и 'marks'.
        - end_date (datetime, optional): Конечная дата для 'weeks' и 'marks'.
        - quarter (int, optional): Номер четверти для 'ranking'.
        - study_year (int, optional): Учебный год для 'ranking'.

        **Алгоритм работы**:
        1. Проверяет, что `analysis_type` является допустимым ('weeks', 'marks', 'ranking').
           Если нет, возвращает сообщение об ошибке.
        2. Загружает промпты из `prompts.json` через `_read_prompts`.
        3. Извлекает промпт для указанного типа анализа. Если промпт не найден, возвращает ошибку.
        4. В зависимости от типа анализа:
           - Для 'weeks': Проверяет наличие `start_date` и `end_date`, получает расписание и тесты,
             форматирует данные в JSON и подставляет в промпт.
           - Для 'marks': Проверяет наличие `start_date` и `end_date`, получает оценки,
             форматирует в JSON и подставляет в промпт.
           - Для 'ranking': Проверяет наличие `quarter`, получает рейтинг класса,
             форматирует в JSON и подставляет в промпт.
        5. Отправляет сформированный промпт в AI через `make_ai_request`.
        6. Логирует ошибки и возвращает ответ AI или сообщение об ошибке.

        **Возвращаемые значения**:
        - str: Ответ AI (человекочитаемый текст) или сообщение об ошибке.

        **Исключения**:
        - Exception: Ошибки загрузки промптов, запросов к API или AI.
          Обрабатываются внутри метода, возвращается сообщение об ошибке.

        **Пример использования**:
        ```python
        analysis = await formatter.analyze_data(
            analysis_type='marks',
            start_date=datetime(2025, 5, 1),
            end_date=datetime(2025, 5, 31)
        )
        print(analysis)
        ```

        **Ошибки и их обработка**:
        - **Некорректный тип анализа**: Если `analysis_type` не в списке допустимых,
          возвращается сообщение об ошибке. Решение: Указать правильный тип.
        - **Отсутствие промпта**: Если промпт для типа не найден в `prompts.json`,
          возвращается ошибка. Решение: Проверить файл `prompts.json`.
        - **Отсутствие параметров**: Для 'weeks' и 'marks' требуются даты, для 'ranking' — четверть.
          Если не указаны, возвращается ошибка. Решение: Указать необходимые параметры.
        - **Ошибка API или AI**: Если запросы к Дневник.ру или DeepSeek не удаются,
          возвращается сообщение об ошибке. Решение: Проверить токен, ключ API, соединение.

        **Замечания**:
        - Метод зависит от внешнего AI-сервиса, что делает его уязвимым к сбоям OpenRouter.
        - Форматирование данных в JSON упрощает передачу в AI, но требует корректных промптов.
        - Ответ AI может быть длинным, что нужно учитывать при отправке через Telegram
          (ограничение 4096 символов).
        """
        valid_types = ['weeks', 'marks', 'ranking']
        if analysis_type not in valid_types:
            self._log(f"Некорректный тип анализа: {analysis_type}. Допустимые типы: {valid_types}")
            return f"Ошибка: Некорректный тип анализа '{analysis_type}'"

        try:
            prompts = await self._read_prompts()
            prompt_text = prompts.get(analysis_type, "")
            if not prompt_text:
                self._log(f"Промпт для типа '{analysis_type}' не найден в prompts.json")
                return f"Ошибка: Промпт для '{analysis_type}' не найден"

            if analysis_type == 'weeks':
                if not start_date or not end_date:
                    self._log("Для анализа недель требуются start_date и end_date")
                    return "Ошибка: Укажите start_date и end_date"
                schedule_data = await self.get_formatted_schedule(start_date, end_date)
                works_data = await self.get_upcoming_tests()
                full_prompt = prompt_text.format(
                    schedule_data=json.dumps(schedule_data, ensure_ascii=False, indent=2),
                    works_data=json.dumps(works_data, ensure_ascii=False, indent=2)
                )
            elif analysis_type == 'marks':
                if not start_date or not end_date:
                    self._log("Для анализа оценок требуются start_date и end_date")
                    return "Ошибка: Укажите start_date и end_date"
                marks_data = await self.get_formatted_marks(start_date, end_date)
                full_prompt = prompt_text.format(
                    marks_data=json.dumps(marks_data, ensure_ascii=False, indent=2)
                )
            elif analysis_type == 'ranking':
                if not quarter:
                    self._log("Для анализа рейтинга требуется quarter")
                    return "Ошибка: Укажите quarter"
                ranking_data = await self.get_class_ranking(quarter, study_year)
                full_prompt = prompt_text.format(
                    ranking_data=json.dumps(ranking_data, ensure_ascii=False, indent=2)
                )

            response = await self.make_ai_request(full_prompt)
            return response

        except Exception as e:
            self._log(f"Ошибка при выполнении анализа '{analysis_type}': {str(e)}")
            return f"Ошибка при выполнении анализа '{analysis_type}': {str(e)}"

async def main():
    token = "API_KEY "  # Замените на ваш токен
    formatter = DnevnikFormatter(token=token, debug_mode=True)
    console = Console()
    await formatter.initialize()

    try:
        await formatter._load_students()
        console.print(f"[bold green]Учеников в кэше: {len(formatter._student_cache)}[/bold green]")
        work_id = 2338040528845190453
        marks = await formatter._get_work_marks_by_id(work_id)
        table = Table(title=f"Оценки за работу {work_id}", box=box.ROUNDED, show_header=True, header_style="bold magenta")
        table.add_column("Ученик", style="cyan", no_wrap=True)
        table.add_column("Оценка", justify="center")
    
        if not marks:
            console.print("[bold red]Оценки не найдены.[/bold red]")
        else:
            for mark in sorted(marks, key=lambda x: x["name"].split()[-1]):
                mark_value = mark["mark"]
                color = (
                    "green" if mark_value == "5" else
                    "green" if mark_value == "4" else
                    "yellow" if mark_value == "3" else
                    "red" if mark_value == "2" else
                    "white"
                )
                table.add_row(mark["name"], f"[{color}]{mark_value}[/{color}]")
        
        console.print(table)
        console.print(f"[bold]Всего оценок: {len(marks)}[/bold]")
        
    except Exception as e:
        console.print(f"[bold red]Ошибка: {e}[/bold red]")
        formatter._log(f"Ошибка в main: {e}", "ERROR")

if __name__ == "__main__":
    asyncio.run(main())
